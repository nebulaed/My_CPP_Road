本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用

# 1 模板

## 1.1 模板的概念

模板就是建立**通用的模具**，大大提高**复用性**

模板的特点：

- 模板不可以直接使用，它只是一个框架
- 模板的通用并不是万能的

## 1.2 函数模板

- C++另一种编程思想称为 ==泛型编程==，主要利用的技术就是模板
- C++提供两种模板机制：**函数模板**和**类模板**

### 1.2.1 函数模板语法

函数模板作用：

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。

**语法：**

```c++
template<typename T>
// 函数声明或定义
```

**解释：**

template -- 声明创建模板

typename -- 表明其后面的符号是一种数据类型，可以用class代替

T -- 通用的数据类型，名称可以替换，通常写为大写字母



总结：

- 函数模板利用关键字template
- 使用函数模板有两种方式：自动类型推导、显式指定类型
- 模板的目的是为了提高复用性，将类型参数化

### 1.2.2 函数模板注意事项

注意事项：

- 自动类型推导，必须推导出一致的数据类型T，才可以使用
- 模板必须要确定出T的数据类型，才可以使用

总结：

- 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型

### 1.2.3 函数模板案例

案例描述：

- 利用函数模板封装一个排序的函数，可以对**不同数据类型数组**进行排序
- 排序规则从大到小，排序算法为**选择排序**
- 分别利用**char数组**和**int数组**进行测试

### 1.2.4 普通函数与函数模板的区别

**普通函数与函数模板的区别：**

- 普通函数调用时可以发生自动类型转换(隐式类型转换)
- 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
- 如果利用显式指定类型的方式，可以发生隐式类型转换

总结：建议使用显式指定类型的方式，调用函数模板，因为可以自己确定通用类型T

### 1.2.5 普通函数与函数模板的调用规则

调用规则如下：

1. 如果函数模板和普通函数都能实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 若函数模板可以产生更好的匹配，优先调用函数模板

总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

### 1.2.6 模板的局限性

**局限性：**

- 模板的通用性并不是万能的

例如：

```c++
template<class T>
void f(T a, T b)
{
	a = b;
}
```

在上述代码中，若传入的a和b是一个数组，就无法实现。

再例如：

```c++
template<class T>
void f(T a, T b)
{
	if(a > b){...}
}
```

在上述代码中，若T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行

C++为解决这种问题，提供模板的重载，可以为这些**特定的类型**提供**具体化的模板**

总结：

- 利用具体化的模板，可以解决自定义类型的通用化
- 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板

## 1.3 类模板

### 1.3.1 类模板语法

类模板作用：

- 建立一个通用类，类中的成员数据类型可以不具体制定，用一个**虚拟的类型**来代表

**语法：**

```c++
template<typename T>
类
```

**解释：**

template -- 声明创建模板

typename -- 表明其后面的符号是一种数据类型，可以用class代替

T -- 通用的数据类型，名称可以替换，通常为大写字母

总结：类模板和函数模板语法相似，在声明模板template后面可以加类，此类称为类模板

### 1.3.2 类模板与函数模板区别

类模板与函数模板区别主要有两点：

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

总结：

- 类模板使用只能用显式指定类型方式
- 类模板中的模板参数列表可以有默认参数

### 1.3.3 类模板中成员函数创建时机

类模板中成员函数和普通类中成员函数创建时机是有区别的：

- 普通类中的成员函数一开始就可以创建
- 类模板中的成员函数在调用时才可以创建

总结：类模板中的成员函数并不是一开始就创建的，而是在调用时才去创建

### 1.3.4 类模板对象做函数参数

学习目标：

- 类模板实例化出的对象，向函数传参的方式

一共有三种传入方式：

1. 指定传入的类型 ——直接显示对象的数据类型
2. 参数模板化 ——将对象中的参数变为模板进行传递
3. 整个类模板化 —— 将这个对象类型 模板化进行传递

总结：

- 通过类模板创建的对象，可以有三种方式向函数中进行传参
- 使用比较广泛的是第一种：指定传入的类型

### 1.3.5 类模板与继承

当类模板碰到继承时，需注意以下几点：

- 当子类继承的父类是一个类模板时，子类在声明时，要指定出父类中T的类型
- 如果不指定，编译器无法给子类分配内存
- 如果想灵活指定出父类中T的类型，子类也需变为类模板

 总结：如果父类是类模板，子类需要指定出父类中T的数据类型

### 1.3.6 类模板成员函数类外实现

学习目标：能够掌握类模板中的成员函数类外实现

总结：类模板中成员函数类外实现时，需要加上模板参数列表

### 1.3.7 类模板分文件编写

学习目标：

- 掌握类模板成员函数分文件编写产生的问题以及解决方式

问题：

- 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

解决：

- 解决方式1：直接包含.cpp源文件
- 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，.hpp是约定的名称，并不是强制

总结：主流解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp

### 1.3.8 类模板与友元

学习目标：

- 掌握类模板配合友元函数的类内和类外实现

全局函数类内实现 - 直接在类内声明友元即可

全局函数类外实现 - 需要提前让编译器知道全局函数的存在

总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别

### 1.3.9 类模板案例

案例描述：实现一个通用的数组类，要求如下：

- 可以对内置数据类型以及自定义数据类型的数据进行存储
- 将数组中的数据存储到堆区
- 构造函数中可以传入数组的容量
- 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
- 提供尾插法和尾删法对数组中的数据进行增加和删除
- 可以通过下标的方式访问数组中的元素
- 可以获取数组中当前元素个数和数组的容量

总结：

能够利用所学知识点实现通用的数组

