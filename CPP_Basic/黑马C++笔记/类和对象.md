# 类和对象

C++面向对象的三大特性为：==封装、继承、多态==

## 4.1 封装

### 4.1.1 封装的意义

封装是C++面向对象三大特性之一

封装的意义：

- 将属性和行为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

封装意义一：

​        在设计类的时候，属性和行为写在一起，表现事物

语法：` class 类名{ 访问权限：属性/行为};`

### 4.1.2 struct和class区别

在C++中struct和class唯一的区别就在于默认的访问权限不同

区别：

- struct默认权限为公共
- class默认权限为私有

### 4.1.3 成员属性设置为私有

**优点1：** 将所有成员属性设置为私有，可以自己控制读写权限
**优点2：** 对于写权限，我们可以检测数据的有效性

## 4.2 对象的初始化和清理

- C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。

### 4.2.1 构造函数和析构函数

对象的**初始化和清理**是两个非常重要的安全问题

一个对象或者变量没有初始状态，对其使用结果是未知

同样使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



C++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器提供的构造函数和析构函数是空实现。



- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。



**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次

**析构函数语法：**`~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用构造，无须手动调用，而且只会调用一次

### 4.2.2 构造函数的分类及调用

两种分类方式：

按参数分为：有参构造和无参构造

按类型分为：普通构造和拷贝构造

三种调用方式：

括号法

显示法

隐式转换法

### 4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

### 4.2.4 构造函数调用规则

默认情况下，C++编译器至少给一个类添加3个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

- 如果用户定义有参构造函数，C++不再提供默认无参构造函数，但是会提供默认拷贝构造函数
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

### 4.2.5 深拷贝与浅拷贝

深浅拷贝是面试经典问题，也是常见的坑

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

![image-20210904193950434](C:\Users\Nebulae\AppData\Roaming\Typora\typora-user-images\image-20210904193950434.png)

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

### 4.2.6 初始化列表

**作用：**

C++提供了初始化列表语法，用来初始化属性

**语法：**`构造函数(): 属性1(值1)，属性2(值2)...{} `

### 4.2.7 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称该成员为对象成员

例如：

```c++
class A {}
class B
{
	A a;
}
```

B类中有对象A作为成员，A为对象成员

那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？

当其他类对象作为本类成员，构造时先构造其他类对象，再构造自身，析构的顺序与构造相反

### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字，称为静态成员

静态成员分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享同一个函数
  - 静态成员函数只能访问静态成员变量

## 4.3 C++对象模型和this指针

### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上，静态成员变量、静态或非静态成员函数均不属于类的对象上

空类对象占用内存空间为：1

### 4.3.2 this指针概念

每一个非静态成员函数只会诞生一份函数实例，即多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分哪个对象调用自己的呢？



C++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用`return *this`

### 4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针



如果用到this指针，需要加以判断保证代码的鲁棒性

### 4.3.4 const修饰成员函数

**常函数：**

- 成员函数后面加const后我们称这个函数为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象：**

- 声明对象前加const称该对象为常对象
- 常对象只能调用常函数

## 4.4 友元

在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

友元的目的就是让一个函数或者类访问另一个类中的私有成员

友元的关键字为 ==friend==

友元的三种实现

- 全局函数做友元
- 类做友元
- 成员函数做友元

## 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加的运算

> 总结1：对于内置的数据类型的表达式的运算符是不可能改变的
>
> 总结2：不要滥用运算符重载

### 4.5.2 左移运算符重载

作用： 可以输出自定义数据类型

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型

### 4.5.3 递增运算符重载

作用：通过重载递增运算符，实现自己的整型数据

### 4.5.4 赋值运算符重载

C++编译器至少给一个类添加4个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符operator=，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题

### 4.5.5 关系运算符重载

**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作

### 4.5.6 函数调用运算符重载

- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活

## 4.6 继承

**继承是面向对象三大特性之一**

有些类与类之间存在特殊的关系，例如下图中

![image-20210908092250600](C:\Users\Nebulae\AppData\Roaming\Typora\typora-user-images\image-20210908092250600.png)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性

这个时候我们就可以考虑利用继承的技术，减少重复代码

### 4.6.1 继承的基本语法

例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同

接下来我们分别利用普通写法和继承写法来实现网页中的内容，看一下继承存在的意义和好处

**总结：**

继承的好处：==可以减少重复的代码==

`class A : public B;`

A类称为子类 或 派生类

B类称为父类 或基类



**派生类中的成员，包含两大部分：**

一类是从基类继承过来的，一类是自己增加的成员。

从基类继承过来的表现其共性，而新增的成员体现了其个性。

### 4.6.2 继承方式

继承的语法：`class 子类 : 继承方式 父类`

**继承方式一共有三种：**

- 公共继承
- 保护继承
- 私有继承

![image-20210908100559054](C:\Users\Nebulae\AppData\Roaming\Typora\typora-user-images\image-20210908100559054.png)

### 4.6.3 继承中的对象模型

**问题：**从父类继承过来的成员，哪些属于子类对象中？

答案：都属于

### 4.6.4 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序是谁先谁后？

> 总结：继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反

### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

总结：

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中所有同名成员函数(包括函数重载)，加作用域可以访问到父类中同名函数

### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问方式(通过对象 和 通过类名)

### 4.6.7 多继承语法

C++允许**一个类继承多个类**

语法：`class 子类 : 继承方式 父类1, 继承方式 父类2...`

多继承可能会引发父类中有同名成员出现，需要加作用域区分

**C++实际开发中不建议用多继承**

> 总结：多继承中如果父类中出现了同名情况，子类使用时要加作用域

### 4.6.8 菱形继承

**菱形继承概念：**

两个派生类继承同一个基类

又有某个类同时继承这两个派生类

这种继承被称为菱形继承，或者钻石继承

![image-20210908152556364](C:\Users\Nebulae\AppData\Roaming\Typora\typora-user-images\image-20210908152556364.png)

**菱形继承问题：**

1. 羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性。
2. 羊驼继承自动物的数据继承了两份，其实我们应该清除，这份数据我们只需要一份就可以。

使用虚继承后，Alpaca类只继承了两个指针，而非两个m_Age变量

![image-20210908154154225](C:\Users\Nebulae\AppData\Roaming\Typora\typora-user-images\image-20210908154154225.png)

vbptr:

v - virtual

b - base

ptr - pointer

vbptr是一个指针，指向vbtable，即虚基类表。

base class Sheep的vbptr指向Sheep的虚基类表，表中记录了偏移量8，加上偏移量后就是m_Age的地址

base class Camel的vbptr指向Camel的虚基类表，表中记录了偏移量4，加上偏移量后就是m_Age的地址

总结：

- 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费
- 利用虚继承可以解决菱形继承问题

## 4.7 多态

### 4.7.1 多态的基本概念

**多态是C++面向对象三大特性之一**

多态分为两类

- 静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

总结：

动态多态满足条件

- 有继承关系
- 子类重写父类中的虚函数

多态使用条件

- 父类指针或引用指向子类对象

重写：函数返回值类型 函数名 参数列表 完全一致称为重写

使用虚函数时，类内有一指针vfptr

vfptr - 虚函数(表)指针:

v - virtual

f - function

ptr - pointer

vfptr指向vftable，即虚函数表。表内部记录虚函数的地址。

当子类重写父类的虚函数，子类中的虚函数表 内部 会替换成 子类的虚函数地址偏移量。

![image-20210908170401593](C:\Users\Nebulae\AppData\Roaming\Typora\typora-user-images\image-20210908170401593.png)

当父类的指针或者引用指向子类对象时，发生多态

```c++
Animal & animal = cat;
animal.speak(); => cat.speak();
&Animal::speak => &Cat::speak
```

### 4.7.2 多态案例一-计算器类

案例描述：

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

多态的优点：

- 代码组织结构清晰
- 可读性强
- 利于前期和后期的扩展以及维护

> 总结：C++开发提倡利用多态设计程序结构，因为多态优点很多

### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都在调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0;`

当类中有纯虚函数，这个类也称为==抽象类==

**抽象类特点：**

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

### 4.7.4 多态案例二-制作饮品

**案例描述：**

制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料

利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

### 4.7.5 虚析构和纯虚析构

多态使用时，若子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

`virtual ~类名() = 0;`

`类名::~类名(){}`

总结：

1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 若子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也属于抽象类

### 4.7.6 多态案例三-电脑组装

**案例描述：**

电脑主要组成部件为CPU(用于计算)，显卡(用于显示)，内存条(用于存储)

将每个零件封装成抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商

创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口

测试时组装三台不同的电脑进行工作