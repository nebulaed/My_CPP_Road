# 构造/析构/赋值运算

## 05：了解C++默默编写并调用哪些函数

**没有声明任何构造函数时，编译器会自动声明一个default构造函数。没有声明copy构造函数，copy assignment操作符和析构函数时，编译器会自动声明对应的函数。**

写下

```c++
class Empty {};
```

等同于

```c++
class Empty{
public:
    Empty() { ... }								// default构造函数
    Empty(const Empty& rhs) { ... }				// copy构造函数
    ~Empty() { ... }							// 析构函数
    Empty& operator=(const Empty& rhs) { ... }	// copy assignment操作符
};
```

除非该class的基类自身声明有virtual析构函数，编译器自动生成的析构函数是non-virtual的。

**编译器自动生成的copy构造函数和copy assignment操作符只是将来源对象的每一个non-static成员变量拷贝到目标对象。**

copy构造函数的调用过程如下：

```c++
template<typename T>
class NamedObject{
public:
    NamedObject(const char* name, const T& value);
    NamedObject(const std::string& name, const T& value);
private:
    std::string nameValue;
    T objectValue;
};

NamedObject<int> no1("Smallest Prime Number", 2);
NamedObject<int> no2(no1);
```

由于nameValue的类型是string，标准string有copy构造函数，因此no2.nameValue的初始化方式时调用string的copy构造函数并以no1.nameValue为实参。

另一个成员变量NamedObject\<int>::objectValue的是内置类型int，因此no2.objectValue会直接拷贝no1.objectValue中每一个bit来完成初始化。

**copy assignment操作符只有当生出的代码合法，且有适当机会证明它有意义，编译器才会自动生成。**例如：

```c++
template<class T>
class NamedObject{
public:
    // 以下构造函数不再接受一个const的name
    // 因为nameValue已经是reference-to-non-const-string
    NamedObject(std::string& name, const T& value);
private:
    std::string& nameValue;	// 是reference
    const T objectValue;	// 是const
};

std::string newDog("Persephone");
std::string oldDog("Satch");
NamedObject<int> p(newDog, 2);
NamedObject<int> s(oldDog, 36);
p = s;
```

由于p.nameValue是个reference，不可改变指向，p.objectValue是const，也不能更改。因此编译器无法生成copy assignment操作符。这时必须自己定义copy assignment操作符。

还有一种情况：**某个基类把copy assignment操作符声明为private，那么其派生类将无法由编译器自动生成copy assignment操作符。**

> 05总结：
>
> - 编译器可以自动为class创建default构造函数，copy构造函数，copy assignment操作符以及析构函数。

## 06：若不想使用编译器自动生成的函数，就要明确拒绝

**要阻止所设计类进行copy构造或copy assignment，可以将copy构造函数或copy assignment操作符声明为private，并且不定义(实现)它们。**例如：

```c++
class HomeForSale{
public:
    ...
private:
    ...
    HomeForSale(const HomeForSale&);			// 不定义，甚至不写参数名称
    HomeForSale& operator=(const HomeForSale&);
};
```

这样客户在拷贝HomeForSale对象时，编译器会阻止。如果在member函数或friend函数中这么做，连接器会阻止。

为将连接期的错误移至编译期，还有一种方式是：**将copy构造函数和copy assignment操作符在一个专门为阻止copy动作而设计的基类内声明为private，并让不允许被copy的类继承它。**

```c++
class Uncopyable{
protected:
    Uncopyable() {}
    ~Uncopyable() {}
private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};
class HomeForSale: private Uncopyable { ... };
```

也可以使用Bosst提供的版本，名为noncopyable。

> 06总结：
>
> - 为驳回编译器自动提供的机能，可将相应的成员函数声明为private并不予实现，或使用像Uncopyable这样的基类。

## 07：为多态基类声明virtual析构函数

```c++
class TimeKeeper{
public:
    TimeKeeper();
    ~TimeKeeper();
    ...
};
class AtomicClock: public TimeKeeper { ... }; 
class WaterClock: public TimeKeeper { ... };
class WristWatch: public TimeKeeper { ... };
```

在以上背景下，设计一不关心时间如何计算的factory函数，返回指针指向一个计时对象。该函数会返回一个基类指针，指向新生成的派生类对象。

```c++
TimeKeeper* getTimeKeeper();
```

为遵守factory函数的规矩，被getTimeKeeper()返回的对象必须位于heap。因此为避免内存泄漏，factory函数返回的每一个对象都需要适当地delete：

```c++
TimeKeeper* ptk = getTimeKeeper();
...
delete ptk;
```

问题来了：getTimeKeeper返回的指针指向一个派生类对象，而那个对象却经由一个基类指针被删除，而目前的基类只有non-virtual析构函数。这时派生类对象的派生成分(也就是声明于派生类中的成员变量)没被销毁，派生类的析构函数也未能执行起来。这造成了局部销毁的对象，会带来资源泄露，数据结构败坏等等。