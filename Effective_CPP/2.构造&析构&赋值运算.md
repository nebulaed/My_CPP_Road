# 构造/析构/赋值运算

## 05：了解C++默默编写并调用哪些函数

**没有声明任何构造函数时，编译器会自动声明一个default构造函数。没有声明copy构造函数，copy assignment操作符和析构函数时，编译器会自动声明对应的函数。**

写下

```c++
class Empty {};
```

等同于

```c++
class Empty{
public:
    Empty() { ... }								// default构造函数
    Empty(const Empty& rhs) { ... }				// copy构造函数
    ~Empty() { ... }							// 析构函数
    Empty& operator=(const Empty& rhs) { ... }	// copy assignment操作符
};
```

除非该class的基类自身声明有virtual析构函数，编译器自动生成的析构函数是non-virtual的。

**编译器自动生成的copy构造函数和copy assignment操作符只是将来源对象的每一个non-static成员变量拷贝到目标对象。**

copy构造函数的调用过程如下：

```c++
template<typename T>
class NamedObject{
public:
    NamedObject(const char* name, const T& value);
    NamedObject(const std::string& name, const T& value);
private:
    std::string nameValue;
    T objectValue;
};

NamedObject<int> no1("Smallest Prime Number", 2);
NamedObject<int> no2(no1);
```

由于nameValue的类型是string，标准string有copy构造函数，因此no2.nameValue的初始化方式时调用string的copy构造函数并以no1.nameValue为实参。

另一个成员变量NamedObject\<int>::objectValue的是内置类型int，因此no2.objectValue会直接拷贝no1.objectValue中每一个bit来完成初始化。

**copy assignment操作符只有当生出的代码合法，且有适当机会证明它有意义，编译器才会自动生成。**例如：

```c++
template<class T>
class NamedObject{
public:
    // 以下构造函数不再接受一个const的name
    // 因为nameValue已经是reference-to-non-const-string
    NamedObject(std::string& name, const T& value);
private:
    std::string& nameValue;	// 是reference
    const T objectValue;	// 是const
};

std::string newDog("Persephone");
std::string oldDog("Satch");
NamedObject<int> p(newDog, 2);
NamedObject<int> s(oldDog, 36);
p = s;
```

由于p.nameValue是个reference，不可改变指向，p.objectValue是const，也不能更改。因此编译器无法生成copy assignment操作符。这时必须自己定义copy assignment操作符。

还有一种情况：**某个基类把copy assignment操作符声明为private，那么其派生类将无法由编译器自动生成copy assignment操作符。**

> 05总结：
>
> - 编译器可以自动为class创建default构造函数，copy构造函数，copy assignment操作符以及析构函数。

## 06：若不想使用编译器自动生成的函数，就要明确拒绝

**要阻止所设计类进行copy构造或copy assignment，可以将copy构造函数或copy assignment操作符声明为private，并且不定义(实现)它们。**例如：

```c++
class HomeForSale{
public:
    ...
private:
    ...
    HomeForSale(const HomeForSale&);			// 不定义，甚至不写参数名称
    HomeForSale& operator=(const HomeForSale&);
};
```

这样客户在拷贝HomeForSale对象时，编译器会阻止。如果在member函数或friend函数中这么做，连接器会阻止。

为将连接期的错误移至编译期，还有一种方式是：**将copy构造函数和copy assignment操作符在一个专门为阻止copy动作而设计的基类内声明为private，并让不允许被copy的类继承它。**

```c++
class Uncopyable{
protected:
    Uncopyable() {}
    ~Uncopyable() {}
private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};
class HomeForSale: private Uncopyable { ... };
```

也可以使用Bosst提供的版本，名为noncopyable。

> 06总结：
>
> - 为驳回编译器自动提供的机能，可将相应的成员函数声明为private并不予实现，或使用像Uncopyable这样的基类。

## 07：为多态基类声明virtual析构函数

```c++
class TimeKeeper{
public:
    TimeKeeper();
    ~TimeKeeper();
    ...
};
class AtomicClock: public TimeKeeper { ... }; 
class WaterClock: public TimeKeeper { ... };
class WristWatch: public TimeKeeper { ... };
```

在以上背景下，设计一不关心时间如何计算的factory函数，返回指针指向一个计时对象。该函数会返回一个基类指针，指向新生成的派生类对象。

```c++
TimeKeeper* getTimeKeeper();
```

为遵守factory函数的规矩，被getTimeKeeper()返回的对象必须位于heap。因此为避免内存泄漏，factory函数返回的每一个对象都需要适当地delete：

```c++
TimeKeeper* ptk = getTimeKeeper();
...
delete ptk;
```

问题来了：getTimeKeeper返回的指针指向一个派生类对象，而那个对象却经由一个基类指针被删除，而目前的基类只有non-virtual析构函数。这时派生类对象的派生成分(也就是声明于派生类中的成员变量)没被销毁，派生类的析构函数也未能执行起来。这造成了局部销毁的对象，会带来资源泄露，数据结构败坏等等。

解决办法很简单：**给基类一个virtual析构函数。**此后删除派生类对象就会销毁整个对象，包括所有派生类成分：

```c++
class TimeKeeper{
public:
    TimeKeeper();
    virtual ~TimeKeeper();
};
TimeKeeper *ptk = getTimeKeeper();
...
delete ptk;
```

virtual函数的目的是允许派生类的实现得以客制化。基类也可以将其他函数设置为virtual函数，这样不同的派生类中可以有不同的实现码。任何class只要带有virtual函数都几乎确定应该有一个virtual析构函数。

在class中不含virtual函数，通常也等于它不企图被当作基类，不要让它的析构函数为virtual。

对于类：

```c++
class Point{
public:
    Point(int xCoord, int yCoord);
    ~Point();
private:
    int x, y;
};
```

如果int占用32bits，那么Point对象可塞入一个64-bit缓存器中。Point对象甚至可被当作一个"64-bit量"传给其他语言如C等撰写的函数。

virtual函数会使得对象携带一个vptr(virtual table pointer)指针，它指向一个由函数指针构成的数组，称为vbtl(virtual table)；每一个带有virtual函数的class都有相应的vtbl。当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vbtl，编译器会在其中寻找适当的函数指针。

如果Point class内含virtual函数，其对象的体积会增加。在32-bit计算机中，将占用64 bits至96 bits(2 ints + vptr)；在64-bit计算机中，可能占用64~128bits(2 ints + vptr(在64-bit计算机中占64 bits))。此时Point对象不再能塞入一个64-bit缓存器，也不再和其他语言内的相同声明有一样的结构，因此也就不再可能把它传递至其他语言所写的函数。

总结：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。

即使class完全不带virtual函数，也要注意。例如：由于标准string不含任何virtual函数，不要将它作为基类。例如：

```c++
class SpecialString: public std::string{
	...  
};
```

在程序中如果无意将一个pointer-to-SpecialString转换为pointer-to-string，然后将该指针delete掉，会立即导致不明确行为。如：

```c++
SpecialString* pss =new SpecialString("Impending Doom");
std::string* ps;
...
ps = pss;
...
delete ps;	// Error!!!*ps的SpecialString部分会泄露，因为SpecialString析构函数未被调用
```

因此，不要继承任何不带virtual析构函数的class，包括所有STL容器如vector, list, set, unordered_map...

要让一个不带任何pure virtual函数的class成为抽象class，可以给它一个pure virtual析构函数，如：

```c++
class AMOV{
public:
    virtual ~AMOV() = 0;	// 声明pure virtual析构函数
};
```

此外，还必须为这个pure virtual函数提供一份定义：

```c++
AMOV::~AMOV() {}
```

析构函数的运作方式是：最深层派生的class的析构函数最先被调用，然后是它每一个基类的析构函数被调用。编译器会在AMOV的派生类的析构函数中创建一个对~AMOV()的调用动作，因此必须为这个函数提供定义。

> 07总结：
>
> - polymorphic(带有多态性质的)基类应该声明一个virtual析构函数。若class带有任何virtual函数，它就应该拥有一个virtual析构函数。
> - class的设计目的若不是作为基类使用，或不是为具备多态性，就不应声明virtual析构函数。

## 08：别让异常逃离析构函数

C++不禁止析构函数吐出异常，但不鼓励。考虑以下代码：

```c++
class Widget{
public:
    ...
    ~Widget() { ... } // 假设这可能吐出一个异常
};
void doSth()
{
    std::vector<Widget> v;
} 					  // v在这里被自动销毁
```

当v被销毁，内含的十个Widgets被析构时，会抛出多个异常。在两个异常同时存在的情况下，程序若不结束执行就会导致不明确行为。

例如，假设使用一个class负责数据库连接

```c++
class DBConnection{
public:
	...
    static DBConnection create();	// 这个函数返回
    
    void close();					// 关闭联机；失败则抛出异常
};
```

为确保客户不忘记在DBConnection对象身上调用close()，合理得想到创建一个用来管理DBConnection资源得class，并在其析构函数中调用close：

```c++
class DBConn{
public:
    ...
    ~DBConn()
    {
        db.close();		// 确保数据库连接总是会被关闭
    }
private:
    DBConnection db;
};
```

这可能导致客户写出这样的代码：

```c++
{										// 开启一个区块(block)
										// 建立DBConnection对象并
    DBConn dbc(DBConnection::create());	// 交给DBConnection对象以便管理
    									// 通过DBConn的接口
    									// 使用DBConnection对象
}										// 在区块结束点，DBConn对象被销毁，因而自动
										// 为DBConnection对象调用close
```

如果该调用导致异常，DBConn析构函数会传播该异常，会允许它离开这个析构函数。

有两个办法可以解决该问题，DBConn的析构函数可以：

- 如果close抛出异常就结束程序。通常可以调用abort完成：

```c++
DBConn::~DBConn()
{
    try { db.close(); }
    catch (...){
        制作运转记录，记下对close的调用失败等操作;
        std::abort();
    }
}
```

这个做法是在程序遭遇一个在析构期间发生的错误后无法继续执行时，强迫结束程序。这样能阻止异常从析构函数传播出去，也就是调用abort抢先制不明确行为于死地。

- 吞下因调用close而发生的异常：

```c++
DBConn::~DBConn()
{
    try { db.close(); }
    catch (...){
        制作运转记录，记下对close的调用失败;
    }
}
```

但这两种办法都无法对”导致close抛出异常“的情况做出处理。

一个较佳策略是重新设计DBConn接口。如DBConn自己可以提供一个close函数。DBConn也可以追踪其所管理的DBConnection是否已被关闭，并在答案为否时由其析构函数关闭。这可防止遗失数据库连接。

```c++
class DBConn{
public:
    ...
    void close()
    {
        db.close();
        closed = true;
    }
    ~DBConn()
    {
        if(!closed){
            try{					// 关闭连接(如果用户没关闭)
                db.close();
            }
            catch(...){
                制作运转记录，记下对close的调用失败;
                ...
            }
        }
    }
private:
    DBConnection db;
    bool closed;
};
```

这样做的目的是：如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。

> 总结08：
>
> - 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们或结束程序。
> - 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数中)执行该操作。

## 09：绝不在构造和析构过程中调用virtual函数

假设有一class继承体系，用来塑模股市交易。这样的交易一定要经过审计，因此每当创建一个交易对象，在审计日志(audit log)中也要创建一笔适当记录。

```c++
class Transaction{							// 所有交易的基类
public:
    Transaction();
    virtual void logTransaction() const = 0;// 做出一份因类型不同而不同的日志记录
};
Transaction::Transaction()					// 基类构造函数的实现
{
    ...
    logTransaction();						// 记录这笔交易
}
class BuyTransaction: public Transaction{
public:
    virtual void logTransaction() const;
};
class SellTransaction: public Transaction{
public:
    virtual void logTransaction() cosnt;
};
```

当下面这行被执行时：

```c++
BuyTransaction b;
```

在BuyTransaction构造函数被调用前，Transaction构造函数先被调用。Transaction构造函数的最后一行调用virtual函数logTransaction，这时被调用的logTransaction是Transaction内的版本，而不是派生类BuyTransaction内的版本。可以这么说：**在基类构造期间，virtual函数不是virtual函数。**

原因是：在派生类对象的基类构造期间，对象的类型是基类而不是派生类。不只virtual函数会被编译器解析至基类，若使用运行期类型消息(如dynamic_cast和typeid)，也会把对象视为基类类型。

这同样也适用于析构函数。派生类执行析构函数，当进入基类析构函数后，对象就成为一个基类对象。

注意：侦测构造函数或析构函数运行期间是否调用virtual函数并不都这么容易。若Transaction有多个构造函数，每个都需执行一些相同工作，常见做法是把共同的初始化代码(放进一个初始化函数如init内)：

```c++
class Transaction{
public:
    Transaction()
    { init(); }
    virtual void logTransaction() const = 0;
private:
    void init()
    {
        ...
        logTransaction();
    }
};
```

这样会带来更隐藏的错误。假若logTransaction是一个impure virtual函数，在Transaction内有实现代码