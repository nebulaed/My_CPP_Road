# 资源管理

这一部分的开始是一个基于对象的资源管理办法，建立在C++对构造函数、析构函数、copying函数的基础上。然后接下来一些办法专门用来进行内存管理。

## 13：以对象管理资源

假设使用一个用来模拟投资行为的程序库，其中各种各样的投资类型继承自以下基类：

```c++
class Investment { ... };
```

进一步假设，该程序库通过一个factory函数供应特定的Investment对象：

```c++
Investment* createInvestment(); // 返回指向Investment继承体系内的动态分配对象的指针
```

理论上客户使用了该函数返回的对象后，有责任删除它。但实际上由于各种原因可能并没有做到。

为确保createInvestment返回的资源总是被释放，**需要将资源放进对象内，当控制流离开调用了createInvestment的函数时，该对象的析构函数会自动释放这些资源。**

标准程序库提供的auto_ptr正是针对这种形势而设计的。auto_ptr是个类指针对象，即**智能指针**，其析构函数自动对其所指对象调用delete。具体用法如下：

```c++
void f()
{
    std::auto_ptr<Investment> pInv(createInvestment());	// 调用factory函数
    ...													// 使用pInv
}												// 由auto_ptr的析构函数自动删除pInv
```

这个例子体现了以对象管理资源的两个原则：

- 获得资源后立刻放进管理对象(managing object)内。
- 管理对象(managing object)运用析构函数确保资源被释放。

由于auto_ptr被销毁时会自动删除所指物，因此一定要注意**不能让多个auto_ptr同时指向同一对象**。这会导致不明确行为。注意：**auto_ptr在被通过copying函数复制时，会变成null，复制所得的指针指向原auto_ptr指向的资源。**因此无法放在STL容器中。

auto_ptr的替代方案是：引用技术型智能指针(reference-counting smart pointer, RCSP)。RCSP也是个智能指针，持续追踪共有多少对象指向某个资源，并在无人指向它时自动删除该资源。注意RCSP无法打破环状引用(如两个已没被使用的对象彼此互指)，此时无法自动释放。具体用法如下：

```c++
void f(){
    ...
    std::tr1::shared_ptr<Investment> pInv(createInvestment());
    pInv(createInvestment());
    ...
}	// 由shared_ptr的析构函数自动删除pInv
```

RCSP可以正常复制：

```c++
void f()
{
    ...
    // pInv1指向createInvestment返回物
    std::tr1::shared_ptr<Investment> pInv1(createInvestment());
    
    std::tr1::shared_ptr<Investment> pInv2(pInv1); // pInv1和pInv2指向同一对象
    pInv1 = pInv2;								   // 同上，无任何改变
    ...
}												   // pInv1和pInv2被销毁
												   // 它们指向的对象也被销毁
```

tr1::shared_ptr可被用于STL容器。

auto_ptr和tr1::shared_ptr的析构函数中用的是delete而非delete[]，因此**不要在动态分配的数组上使用这两者**，虽然能通过编译。Boost里有针对数组的智能指针和引用：boost::scoped_array，boost::shared_array。

> 13总结：
>
> - 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。
> - 两个常被使用的RAII classes是auto_ptr和tr1::shared_ptr。后者是较佳选择，因为其copy比较直观。

## 14：在资源管理类中小心copying行为

对非heap-based资源，不适合用auto_ptr或tr1::shared_ptr进行资源管理。这就需要建立自己的资源管理类。

例如：假设使用C API函数处理类型为Mutex的互斥器对象(mutex objects)，共有lock和unlock两函数可用

```c++
void lock(Mutex* pm);		// 锁定pm所指的互斥器
void unlock(Mutex* pm);		// 将互斥器解除锁定
```

为确保不会忘记把被锁住的Mutex解锁，可以通过建立一个由RAII守则支配其基本结构的class来管理机锁，RAII守则即资源在构造期间获得，在析构期间释放。

```c++
class Lock{
public:
    explicit Lock(Mutex* pm): mutexPtr(pm) // 获得资源，explicit阻止隐式类型转换
    {
        lock(mutexPtr);
    }
    ~Lock() { unlock(mutexPtr); }	// 释放资源
private:
    Mutex *mutexPtr;
};
```

用法如下：

```c++
Mutex m;
{					// 建立一个定义critical section的区块
    Lock ml(&m);	// 锁定互斥器
    ...				// 执行critical section里的操作
}					// 在区块最末尾，自动解除互斥器锁定
```

但要注意，我们要对这种自定义RAII对象的复制进行处理：

```c++
Lock ml1(&m);	// 锁定m
Lock ml2(ml1);	// 将ml1复制到ml2，不做处理可能会导致指向的东西两次被删除
```

有两种解决办法：

- **禁止复制。**具体做法是将copying操作声明为private并只做声明。如下：

  ```c++
  class Lock: private Uncopyable{		// 禁止复制
  public:
      ...
  };
  ```

- **对底层资源使用引用计数法(reference-count)。**这时候需要保有资源，直到它的最后一个使用者被销毁。复制RAII对象时，应该将资源的被引用数递增。

  通常只要内含一个tr1::shared_ptr成员变量，RAII classes就能表现出相同的引用技术copying行为。但tr1::shared_ptr的默认行为是删除，我们需要的是解除锁定。因此需要自定义tr1::shared_ptr的删除器：
  
  ```c++
  class Lock{
  public:
      explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)	//以某Mutex初始化shared_ptr
      {												// 并以unlock为删除器
          lock(mutexPtr.get());
      }
  private:
      std::tr1::shared_ptr<Mutex> mutexPtr; 			// 使用shared_ptr替换指针
  };
  ```
  
  这里不再需要声明析构函数，因为class析构函数(不管是编译器自动生成的还是人工的)会自动调用其non-static成员变量的析构函数。而mutexPtr的析构函数会在互斥器的引用次数为0时自动调用tr1::shared_ptr的删除器。
  
- **复制底部资源。**即深度拷贝，把指向的对象也拷贝一份。

- **转移底部资源的所有权。**类似于auto_ptr。

> 14总结：
>
> - 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying。
> - 普遍而常见的RAII class copying行为是：抑制copying、引用计数法。

## 15：在资源管理类中提供对原始资源的访问

有例子：

```c++
std::tr1::shared_ptr<Investment> pInv(createInvestment());
```

假设需要以某个函数处理Investment对象：

```c++
int daysHeld(const Investment* pi);	// 返回投资天数
```

下面这样没法通过编译：

```c++
int days = daysHeld(pInv);	// Error!
```

daysHeld需要的是Investment*指针，传给它的却是tr1::shared_ptr\<Investment>对象。

这时需要一个函数将RAII class对象转换为其所内含的原始资源。有两种做法：显式转换和隐式转换。

tr1::shared_ptr和auto_ptr都提供一个get成员函数，用来执行显式转换，如下：

```c++
int days = daysHeld(pInv.get());	// 将Inv内的原始指针传给daysHeld
```

tr1::shared_ptr和auto_ptr重载了指针取值(pointer dereferencing)操作符(operator->和operator*)，允许隐式转换至底部原始指针：

```c++
class Investment{
public:
    bool isTaxFree() const;
};
Investment* createInvestment();	// factory函数
std::tr1::shared_ptr<Investment> pi1(createInvestment());	// 令tr1::shared_ptr
															// 管理一笔资源
bool taxable1 = !(pi1->isTaxFree());	// 经过operator->访问资源
...
std::auto_ptr<Investment> pi2(createInvestment());	// 令auto_ptr管理一笔资源
bool taxable2 = !((*pi2).isTaxFree());	// 经过operator*访问资源
```

自行设计的RAII class同样需要提供一个隐式转换函数。考虑以下字体RAII class：

```c++
FontHandle getFont();	// 这是个C API。
void releaseFont(FontHandle fh);	// 来自同一组C API
class Font{							// RAII class
public:
    explicit Font(FontHandle fh)	// 获得资源
        : f(fh) { }					// 采用值传递
    ~Font() { releaseFont(f); }		// 释放资源
private:
    FontHandle f;					// 原始字体资源
};
```

假设有大量与字体相关的C API要处理FontHandles，那么将Font对象转换乘FontHandle会是一种很频繁的需求。Font class可以为此提供一个显式转换函数：

```c++
class Font{
public:
    FontHandle get() const { return f; }	// 显式转换函数
};
```

但这使得客户每次想要使用API就得调用get：

```c++
void changeFontSize(FontHandle f, int newsize);	// C API
Font f(getFont());
int newFontSize;
...
changeFontSize(f.get(), newFontSize);
```

这增加了泄露字体地可能性。另一个办法是令Font提供隐式转换函数：

```c++
class Font{
public:
    ...
    operator FontHandle() const { return f; }	// 隐式转换函数
    
}
```

