# 资源管理

这一部分的开始是一个基于对象的资源管理办法，建立在C++对构造函数、析构函数、copying函数的基础上。然后接下来一些办法专门用来进行内存管理。

## 13：以对象管理资源

假设使用一个用来模拟投资行为的程序库，其中各种各样的投资类型继承自以下基类：

```c++
class Investment { ... };
```

进一步假设，该程序库通过一个factory函数供应特定的Investment对象：

```c++
Investment* createInvestment(); // 返回指向Investment继承体系内的动态分配对象的指针
```

理论上客户使用了该函数返回的对象后，有责任删除它。但实际上由于各种原因可能并没有做到。

为确保createInvestment返回的资源总是被释放，**需要将资源放进对象内，当控制流离开调用了createInvestment的函数时，该对象的析构函数会自动释放这些资源。**

标准程序库提供的auto_ptr正是针对这种形势而设计的。auto_ptr是个类指针对象，即**智能指针**，其析构函数自动对其所指对象调用delete。具体用法如下：

```c++
void f()
{
    std::auto_ptr<Investment> pInv(createInvestment());	// 调用factory函数
    ...													// 使用pInv
}												// 由auto_ptr的析构函数自动删除pInv
```

这个例子体现了以对象管理资源的两个原则：

- 获得资源后立刻放进管理对象(managing object)内。
- 管理对象(managing object)运用析构函数确保资源被释放。

由于auto_ptr被销毁时会自动删除所指物，因此一定要注意**不能让多个auto_ptr同时指向同一对象**。这会导致不明确行为。注意：**auto_ptr在被通过copying函数复制时，会变成null，复制所得的指针指向原auto_ptr指向的资源。**因此无法放在STL容器中。

auto_ptr的替代方案是：引用技术型智能指针(reference-counting smart pointer, RCSP)。RCSP也是个智能指针，持续追踪共有多少对象指向某个资源，并在无人指向它时自动删除该资源。注意RCSP无法打破环状引用(如两个已没被使用的对象彼此互指)，此时无法自动释放。具体用法如下：

```c++
void f(){
    ...
    std::tr1::shared_ptr<Investment> pInv(createInvestment());
    pInv(createInvestment());
    ...
}	// 由shared_ptr的析构函数自动删除pInv
```

RCSP可以正常复制：

```c++
void f()
{
    ...
    // pInv1指向createInvestment返回物
    std::tr1::shared_ptr<Investment> pInv1(createInvestment());
    
    std::tr1::shared_ptr<Investment> pInv2(pInv1); // pInv1和pInv2指向同一对象
    pInv1 = pInv2;								   // 同上，无任何改变
    ...
}												   // pInv1和pInv2被销毁
												   // 它们指向的对象也被销毁
```

tr1::shared_ptr可被用于STL容器。

auto_ptr和tr1::shared_ptr的析构函数中用的是delete而非delete[]，因此**不要在动态分配的数组上使用这两者**，虽然能通过编译。Boost里有针对数组的智能指针和引用：boost::scoped_array，boost::shared_array。

> 13总结：
>
> - 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。
> - 两个常被使用的RAII classes是auto_ptr和tr1::shared_ptr。后者是较佳选择，因为其copy比较直观。

## 14：在资源管理类中小心copying行为

