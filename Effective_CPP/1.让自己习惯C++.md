# 让自己习惯C++

## 01：视C++为一个语言联邦

目前的C++是多重范型编程语言，同时支持面向过程(procedural)，面向对象(object-oriented)，函数形式(functional)，泛型形式(generic)，元编程形式(meta-programming)。对于这些不同范型，适用的C++用法并不相同。

因此应将C++视为一个由多个次语言组成的联邦，在某个次语言(sublanguage)中，遵循一定守则。从一个次语言改用另一次语言时，守则可能改变。

C++主要有四个次语言：

- C
  - 区块(blocks)
  - 语句(statements)
  - 预处理器(preprocessor)
  - 内置数据类型(built-in data types)
  - 数组(arrays)
  - 指针(pointer)

- Object-Oriented C++
  - classes(包括构造函数和析构函数)
  - 封装(encapsulation)
  - 继承(inheritance)
  - 多态(polymorphism)
  - virtual函数(动态绑定)

- Template C++

- STL
  - 容器(containers)
  - 迭代器(iterators)
  - 算法(algorithms)
  - 函数对象(function objects)

对内置(C-like)类型值传递比引用传递高效，但当使用Object-Oriented C++时，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好，尤其使用Template C++时。但对STL而言，迭代器和函数都是在C指针上塑造出来的，因此对STL的迭代器和函数对象而言，值传递反而适用。

## 02：尽量以const，enum，inline替换 #define

这么做目的是以编译器替换预处理器。因为#define不被视为语言的一部分。

```c++
#define ASPECT_RATIO 1.653
```

ASPECT_RATIO可能不会被编译器看到，它在编译器处理源码之前可能就被预处理器移走了，它不会进入记号表(symbol table)内。

当用该常量获得编译错误信息时，错误信息会直接提示1.653而非ASPECT_RATIO。若ASPECT_RATIO定义在其他人所写的头文件中，debug时很难溯源。

解决办法是用一个常量替换上述宏(#define)：

```c++
const double AspectRatio = 1.653; // 宏用大写名称，这里非宏故名称写法改变
```

作为一个语言常量，AspectRatio会进入记号表内。对浮点常量而言，使用常量比使用#define会引入更小量的码，因为预处理器只要看到ASPECT_RATIO都会替换成1.653，这会导致目标码出现多份1.653，若改用常量不会有这个问题。

以常量替换#define，有两个注意点：

1. 定义常量指针(constant pointers)：常量定义式常放在头文件，故需要将指针声明为const，如要在头文件内定义一个常量的char*-based字符串，需写const两次

```c++
const char* const authorName = "Scott Meyers"
```

也可用string对象代替char*-based，如下

```c++
const std::string authorName("Scott Meyers");
```

2. class专属常量：为将常量的作用域(scope)限制于class内，必须让它成为class的一个成员(member)，为了确保该常量最多只有一份实体，需要让它成为一个static成员。

```c++
class GamePlayer{
private:
	static const int NumTurns = 5; // 常量声明式
	int scores[NumTurns]; // 使用该常量
};
```

这是NumTurns的声明式，实际使用时C++还要求有定义式，但NumTurns是[static与整数类型]的class专属常量(如int, char, bool)，这种特殊情况下只要不取它们的地址，可以只声明不定义就使用它们。但如果要取某个class专属常量的地址(或有时不取地址编译器也要求有定义式)，编译器会要求必须再提供定义式如下：

```c++
const int GamePlayer::NumTurns; // NumTurns的定义
```

该式子需放入源文件而不是头文件。由于class常量在声明时已有初值，不可以再给初值。

另外#define不能创建class专属常量，因为#define没有作用域概念。一旦被定义，在其后的编译过程中都有效 (除非被#undef)，这意味着#define不能被用来定义class专属常量，也不能被封装，因此不可能存在private #define。而const成员变量是ok的。

有些旧编译器可能不支持static成员的in class初值设定，需要将初值放在定义式。

```c++
const int GamePlayer::NumTurns = 5; // NumTurns的定义
```

万一该旧编译器不允许static整型class常量完成in class的初值设定，可改用"the enum hack"。原理是：一个属于枚举类型(enumerated type)的数值可当作int被使用。

```c++
class GamePlayer{
private:
	enum { NumTurns = 5 }; // 令NumTurns成为5的一个记号名称
    
    int scores[NumTurns];
};
```

1. enum hack的行为像#define而不像const，取const的地址是合法的，取enum和#define的地址一般不合法。当不想让别人获得pointer或reference指向该整数常量时，利用enum可实现该约束。另外不好的编译器可能导致整型const对象被分配额外的存储空间，而enum和#define绝不会导致这样的内存浪费。
2. enum hack是template meta-programming的基础技术，需要认识。

另外常见的#define吴用还有用它实现宏(macros)，宏像函数但能避免函数调用的额外开销。

```c++
#define CALL_WITH_MAX(a,b) f((a) > (b) ? (a) : (b))
```

写这种宏时必须为宏中所有实参加上小括号，否则调用时可能遭遇麻烦。但这仍然有问题

```c++
int a = 5, b = 0;
CALL_WITH_MAX(++a,b); // a被累加两次
CALL_WITH_MAX(++a,b+10); // a被累加一次
```

调用f前，a的递增次数不正常地取决于它被拿来与谁比较！

因此这里改用template inline函数

```c++
template<typename T>
inline void callWithMax(const T& a, const T& b) //由于不知道T是啥，采用pass-by-reference-to-const
{
   f(a > b ? a : b);
}
```

该template产出一群函数，每个函数都接受两同型对象，并以较大者调用f。

这样不需要在函数本体中为参数加括号，也不需要担心参数被计算多次。

由于callWithMax是真正函数，其遵守作用域和访问规则，能被写出in-class private inline函数，宏不行。

> 02总结：
>
> - 对单纯常量，最好用const对象或enums替换#define。
> - 对形似函数的宏(macros)，最好用inline函数替换#define。

## 03：尽可能使用const

const出现在星号左边，表示被指物是常量；出现在星号右边，表示指针自身是常量。

const写在类型之前或类型之后、星号之前含义相同。因此以下两个函数接受的参数类型一致：

```c++
void f1(const Widget* pw);
void f2(Widget const *pw);
```

STL迭代器是用指针塑造的，所以迭代器就像个T*指针。声明迭代器为const就像声明一个T\* const指针一样。说明这个迭代器不能指向不同的东西，但所指物的值可改动。若希望迭代器所指物的值不可被改动(即要STL模拟一个const T\* 指针)，应该用const_iterator：

```c++
std::vector<int> vec;
const std::vector<int>::iterator iter = vec.begin();
*iter = 10; // OK!
++iter; // Error!!!

std::vector<int>::const_iterator cIter = vec.begin();
*cIter = 10; // Error!!!
++cIter; // OK!
```

const最重要的用法就是和函数返回值、各参数、函数本身结合使用。

1. 令函数返回一个常量值

```c++
class Rational {...};
const Rational operator* (const Rational& lhs, const Rational& rhs);
```

这是为了避免客户调用*操作符重载时出现这种错误而不报错：

```c++
Rational a, b, c;
(a * b) = c;
if (a * b = c) ... // 明显本意是要if (a * b == c)
```

若a和b是内置类型，这样必然不合法，为了使我们的自定义类型与内置类型兼容，预防错误的赋值，应将operator*的回传值声明为const。

### const 成员函数

const 成员函数能作用于const 对象上。

两个成员函数如果只是常量性不同，可以被重载。

对于

```c++
class TextBlock{
private:
    std::string text;
public:
    // operator[] for const object
    const char& operator[](std::size_t position) const 
    { return text[position]; }
    // operator[] for non-const object
    char& operator[](std::size_t position)
    { return text[position]; }
};
```

有

```c++
TextBlock tb("Hello");
std::cout << tb[0];		// 调用non-const TextBlock::operator[]
const TextBlock ctb("World");
std::cout << ctb[0];	// 调用const TextBlock::operator[]

void print(const TextBlock& ctb)
{
	std::cout << ctb[0]; // 调用const TextBlock::operator[]
}

tb[0] = 'x'; // OK!
ctb[0] = 'x'; // Error!
```

另外，non-const operator[]的返回类型是reference to char，不是char。因此以下句子才能通过编译

```c++
tb[0] = 'x';
```

若函数的返回类型是内置类型，改动函数返回值本就不合法，即使合法被改动的也是tb.text[0]的一个副本，而不是它本身。

const成员函数有两种概念：bitwise constness和logical constness。

1. bitwise constness

const成员函数不能修改对象的任何成员变量(static除外)或者说任何一个bit。

但实际上const成员函数会改变in-class 指针所指物。例如：

```c++
class CTextBlock{
public:
    char& operator[](std::size_t position) const
    { return pText[position]; }
private:
    char* pText;
};

const CTextBlock cctb("Hello"); // 声明一个常量对象
char* pc = &cctb[0];			// 调用const operator[]取得一指针指向cctb的数据
*pc = 'J';						// cctb现在变成"Jello"
```

 这时编译器不会报错，我们创建了一个常量对象并初始化，而且只对它调用const成员函数，结果内部值却发生了改变。

2. logical constness

const成员函数可以修改它处理的对象内的某些bits，但必须在客户端侦测不出的情况下。例如：

```c++
class CTextBlock{
public:
    std::size_t length() const;
private:
    char* pText;
    std::size_t textLength;
    bool lengthIsValid;
};
std::size_t CTextBlock::length() const
{
	if (!lengthIsValid){
        textLength = std::strlen(pText); // Error!!!在const成员函数内不能赋值给
        lengthIsValid = true;		     // textLength 和 lengthIsValid
    }    
    return textLength;
}
```

解决办法：利用C++中的mutable，释放掉non-static成员变量的bitwise constness约束：

```c++
class CTextBlock{
public:
    std::size_t length() const;
private:
    char* pText;
    mutable std::size_t textLength;
    mutable bool lengthIsValid;
};
std::size_t CTextBlock::length() const
{
	if (!lengthIsValid){
        textLength = std::strlen(pText); // OK!
        lengthIsValid = true;
    }    
    return textLength;
}
```

