# 让自己习惯C++

## 01：视C++为一个语言联邦

目前的C++是多重范型编程语言，同时支持面向过程(procedural)，面向对象(object-oriented)，函数形式(functional)，泛型形式(generic)，元编程形式(meta-programming)。对于这些不同范型，适用的C++用法并不相同。

因此应将C++视为一个由多个次语言组成的联邦，在某个次语言(sublanguage)中，遵循一定守则。从一个次语言改用另一次语言时，守则可能改变。

C++主要有四个次语言：

- C
  - 区块(blocks)
  - 语句(statements)
  - 预处理器(preprocessor)
  - 内置数据类型(built-in data types)
  - 数组(arrays)
  - 指针(pointer)

- Object-Oriented C++
  - classes(包括构造函数和析构函数)
  - 封装(encapsulation)
  - 继承(inheritance)
  - 多态(polymorphism)
  - virtual函数(动态绑定)

- Template C++

- STL
  - 容器(containers)
  - 迭代器(iterators)
  - 算法(algorithms)
  - 函数对象(function objects)

对内置(C-like)类型值传递比引用传递高效，但当使用Object-Oriented C++时，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好，尤其使用Template C++时。但对STL而言，迭代器和函数都是在C指针上塑造出来的，因此对STL的迭代器和函数对象而言，值传递反而适用。

## 02：尽量以const，enum，inline替换 #define

这么做目的是以编译器替换预处理器。因为#define不被视为语言的一部分。

```c++
#define ASPECT_RATIO 1.653
```

ASPECT_RATIO可能不会被编译器看到，它在编译器处理源码之前可能就被预处理器移走了，它不会进入记号表(symbol table)内。

当用该常量获得编译错误信息时，错误信息会直接提示1.653而非ASPECT_RATIO。若ASPECT_RATIO定义在其他人所写的头文件中，debug时很难溯源。

解决办法是用一个常量替换上述宏(#define)：

```c++
const double AspectRatio = 1.653; // 宏用大写名称，这里非宏故名称写法改变
```

作为一个语言常量，AspectRatio会进入记号表内。对浮点常量而言，使用常量比使用#define会引入更小量的码，因为预处理器只要看到ASPECT_RATIO都会替换成1.653，这会导致目标码出现多份1.653，若改用常量不会有这个问题。

以常量替换#define，有两个注意点：

1. 定义常量指针(constant pointers)：常量定义式常放在头文件，故需要将指针声明为const，如要在头文件内定义一个常量的char*-based字符串，需写const两次

```c++
const char* const authorName = "Scott Meyers"
```

也可用string对象代替char*-based，如下

```c++
const std::string authorName("Scott Meyers");
```

2. class专属常量：为将常量的作用域(scope)限制于class内，必须让它成为class的一个成员(member)，为了确保该常量最多只有一份实体，需要让它成为一个static成员。

```c++
class GamePlayer{
private:
	static const int NumTurns = 5; // 常量声明式
	int scores[NumTurns]; // 使用该常量
};
```

这是NumTurns的声明式，实际使用时C++还要求有定义式，但NumTurns是[static与整数类型]的class专属常量(如int, char, bool)，这种特殊情况下只要不取它们的地址，可以只声明不定义就使用它们。但如果要取某个class专属常量的地址(或有时不取地址编译器也要求有定义式)，编译器会要求必须再提供定义式如下：

```c++
const int GamePlayer::NumTurns; // NumTurns的定义
```

该式子需放入源文件而不是头文件。由于class常量在声明时已有初值，不可以再给初值。

另外#define不能创建class专属常量，因为#define没有作用域概念。一旦被定义，在其后的编译过程中都有效 (除非被#undef)，这意味着#define不能被用来定义class专属常量，也不能被封装，因此不可能存在private #define。而const成员变量是ok的。

有些旧编译器可能不支持static成员的in class初值设定，需要将初值放在定义式。

```c++
const int GamePlayer::NumTurns = 5; // NumTurns的定义
```

万一该旧编译器不允许static整型class常量完成in class的初值设定，可改用"the enum hack"。原理是：一个属于枚举类型(enumerated type)的数值可当作int被使用。

```c++
class GamePlayer{
private:
	enum { NumTurns = 5 }; // 令NumTurns成为5的一个记号名称
    
    int scores[NumTurns];
};
```

1. enum hack的行为像#define而不像const，取const的地址是合法的，取enum和#define的地址一般不合法。当不想让别人获得pointer或reference指向该整数常量时，利用enum可实现该约束。另外不好的编译器可能导致整型const对象被分配额外的存储空间，而enum和#define绝不会导致这样的内存浪费。
2. enum hack是template meta-programming的基础技术，需要认识。

另外常见的#define吴用还有用它实现宏(macros)，宏像函数但能避免函数调用的额外开销。

```c++
#define CALL_WITH_MAX(a,b) f((a) > (b) ? (a) : (b))
```

写这种宏时必须为宏中所有实参加上小括号，否则调用时可能遭遇麻烦。但这仍然有问题

```c++
int a = 5, b = 0;
CALL_WITH_MAX(++a,b); // a被累加两次
CALL_WITH_MAX(++a,b+10); // a被累加一次
```

调用f前，a的递增次数不正常地取决于它被拿来与谁比较！

因此这里改用template inline函数

```c++
template<typename T>
inline void callWithMax(const T& a, const T& b) //由于不知道T是啥，采用pass-by-reference-to-const
{
   f(a > b ? a : b);
}
```

该template产出一群函数，每个函数都接受两同型对象，并以较大者调用f。

这样不需要在函数本体中为参数加括号，也不需要担心参数被计算多次。

由于callWithMax是真正函数，其遵守作用域和访问规则，能被写出in-class private inline函数，宏不行。

> 02总结：
>
> - 对单纯常量，最好用const对象或enums替换#define。
> - 对形似函数的宏(macros)，最好用inline函数替换#define。

## 03：尽可能使用const

