# 实现

## 26：尽可能延后变量定义式的出现时间

> 26总结：
>
> - 尽可能延后变量定义式的出现。这样可增加程序的清晰性并改善程序效率。

## 27：尽量少做转型动作

C++提供了四种新式转型：

- const_cast\<T>(object): 用于将对象的常量性转除，是唯一具有此能力的C++-style转型操作符。
- dynamic_cast\<T>(object): 同于执行安全向下转型，也就是用于决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。
- reinterpret_cast\<T>(object): 用于执行低级转型，实际动作和结果可能取决于编译器，这也表示它不可移植。
- static_cast\<T>(object): 用于强迫隐式转换，例如将non-const对象转为const，或将int转为double。

> 27总结：
>
> - 若可以，尽量避免转型。特别在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着使用无需转型的替代设计。
> - 若转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。
> - 尽可能使用C++-style新式转型，不要使用旧式转型。

## 28：避免返回handles指向对象内部成分

> 28总结：
>
> - 避免返回handles(包括引用、指针、迭代器)指向对象内部。遵守这个守则可增加封装性，帮助const成员函数的行为像个const，并将发生虚吊号码牌(dangling handles)的可能性降至最低。

## 29：为“异常安全”而努力是值得的

> 29总结：
>
> - 异常安全函数(Exception-safe functions)即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。
> - 强烈保证往往能够以copy-and-swap实现出来，但强烈保证并非对所有函数都可实现或具备现实意义。
> - 函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。

## 30：透彻了解inlining

> 30总结：
>
> - 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。
> - 不要只因为function templates出现在头文件，就将它们声明为inline。

## 31：将文件间的编译依存关系降至最低

> 31总结：
>
> - 支持编译依存性最小化的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。
> - 程序库头文件应该以”完全且仅有声明式“的形式存在。这种做法无论是否设计templates都适用。