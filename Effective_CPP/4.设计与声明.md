# 设计与声明

## 18：让接口容易被正确使用，不易被误用

假设为一个用来表现日期的class设计构造函数：

```c++
class Date{
public:
    Date(int month, int day, int year);
};
```

这时客户可能传参时可能弄错月份、日期、年份的顺序，也可能传递一个无效的月份或天数。

这可以**通过导入新类型来预防。**类型系统是我们防范错误用法的好帮手。我们可以导入简单的外覆类型(wrapper types)来区别天数、月份和年份，然后于Date构造函数中使用这些类型：

```c++
struct Day{
explicit Day(int d): val(d) {}
int val;
};
struct Month{
explicit Month(int m): val(m) {}
int val;
};
struct Year{
explicit Year(int y): val(y) {}
int val;
};
class Date{
public:
    Date(const Month& m, const Day& d, const Year& y);
};
Date d(30, 3, 1995);	// Error!
Date d(Day(30), Month(3), Year(1995));	// Error!
Date d(Month(3), Day(30), Year(1995));	// OK!
```

令Day，Month，Year成为写得更成熟完善的class，是更好的选择。

现在有了正确的类型，限制其值也是合理的。比较安全的解法如下：

```c++
class Month{
public:
    static Month Jan() { return Month(1); }
    static Month Feb() { return Month(2); }
    ...
    static Month Dec() { return Month(12); }
    ...
private:
    explicit Month(int m);
};
Date d(Month::Mar(), Day(30), Year(1995));
```

这里以函数替换对象是为了符合守则4的要求。

预防客户错误的另一个办法是：限制类型内什么事可做，什么事不能做。

> 18总结：
>
> - 好的接口容易被正确使用，不容易被误用。应当在自己设计的所有接口中努力达成这些性质。
> - 促进正确使用的办法包括接口的一致性，以及与内置类型的行为兼容。
> - 阻止误用的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。
> - tr1::shared_ptr支持定制型删除器(custom deleter)。这可防范DLL问题，可被用来自动解除互斥锁(mutexes)等等。

## 19：设计class犹如设计type

> 19总结：
>
> - class的设计就是type的设计。在定义一个新type前，请确定已经考虑过本守则覆盖的所有讨论主题。

## 20：宁以pass-by-reference-to-const替换pass-by-value

可以合理假设pass-by-value并不昂贵的唯一对象是内置类型和STL的迭代器和函数对象。

> 20总结：
>
> - 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。
> - 以上规则不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value比较适当。

## 21：必须返回对象时，别妄想返回其reference

> 21总结：
>
> - 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated(分配到堆的)对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。守则4已为最后一点做出范本。

## 22：将成员变量声明为private

> 22总结：
>
> - 切记将成员变量声明为private，这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。
> - protected并不比public更具封装性。

## 23：宁以non-member、non-friend替换member函数

> 23总结：
>
> - 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。

## 24：若所有参数都需类型转换，请为此采用non-member函数

> 24总结：
>
> - 如果需要为某个函数的所有参数(包括被this指针所指的隐式参数)进行类型转换，那么这个函数必须是non-member。

## 25：考虑写出一个不抛异常的swap函数

> 25总结：
>
> - std::swap对自定义类型的效率不高时，请为自定义类型提供一个swap成员函数，并确定这个函数不抛出异常。
> - 如果我们提供了一个member swap，也应该提供一个non-member swap来调用前者。对于不是templates的classes，请特化std::swap。
> - 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何命名空间资格修饰。
> - 为用户定义类型进行std templates全特化是好的，但千万不要尝试在std内假如某些对std而言全新的东西。