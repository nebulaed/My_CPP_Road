# 设计与声明

## 18：让接口容易被正确使用，不易被误用

假设为一个用来表现日期的class设计构造函数：

```c++
class Date{
public:
    Date(int month, int day, int year);
};
```

这时客户可能传参时可能弄错月份、日期、年份的顺序，也可能传递一个无效的月份或天数。

这可以**通过导入新类型来预防。**类型系统是我们防范错误用法的好帮手。我们可以导入简单的外覆类型(wrapper types)来区别天数、月份和年份，然后于Date构造函数中使用这些类型：

```c++
struct Day{
explicit Day(int d): val(d) {}
int val;
};
struct Month{
explicit Month(int m): val(m) {}
int val;
};
struct Year{
explicit Year(int y): val(y) {}
int val;
};
class Date{
public:
    Date(const Month& m, const Day& d, const Year& y);
};
Date d(30, 3, 1995);	// Error!
Date d(Day(30), Month(3), Year(1995));	// Error!
Date d(Month(3), Day(30), Year(1995));	// OK!
```

令Day，Month，Year成为写得更成熟完善的class，是更好的选择。

现在有了正确的类型，限制其值也是合理的。比较安全的解法如下：

```c++
class Month{
public:
    static Month Jan() { return Month(1); }
    static Month Feb() { return Month(2); }
    ...
    static Month Dec() { return Month(12); }
    ...
private:
    explicit Month(int m);
};
Date d(Month::Mar(), Day(30), Year(1995));
```

这里以函数替换对象是为了符合守则4的要求。

预防客户错误的另一个办法是：限制类型内什么事可做，什么事不能做。常见的限制是加上const。

下面是另一个一般性准则：除非有好丽友，否则尽量令自定义types的行为与内置types一致。例如，若a和b都是int，那么对a*b赋值并不合法。

避免无端与内置类型不兼容，真正的理由是为了提供行为一致的接口。如，STL容器的接口十分一致，这使它们非常容易被使用。

任何接口如果要求客户必须记得某些事情，就是有着不正确使用的倾向。例如守则13中的factory函数：

```c++
Investment* createInvestment();
```

为避免资源泄露，createInvestment返回的指针最终必须被删除。这至少导致了客户的两个错误机会：没有删除指针，或删除同一个指针超过一次。

守则13表明客户可以如何将createInvestment的返回值存储于一个智能指针，从而将delete责任推给智能指针。但如果客户忘记使用智能指针怎么办？因此最好的办法是先发制人，就令factory函数返回一个智能指针：

```c++
std::tr1::shared_ptr<Investment> createInvestment();
```

这强迫了客户将返回值存储于一个tr1::shared_ptr内，避免了忘记使用智能指针的可能性。

假如我们作为class设计者，设计了一个用于释放指针指向资源的getRidOfInvestment函数，期望从createInvestment取得Investment*指针的客户将该指针传递给这个函数。这样的接口可能带来另一个错误，即客户可能会使用错误的资源析构机制(如用了delete而非getRidOfInvestment)。

遵循上面的原则，我们可以将getRidOfInvestment绑定为tr1::shared_ptr的删除器：

```c++
// 企图创建一个null shared_ptr，并携带一个自定的删除器
std::tr1::shared_ptr<Investment> pInv(0, getRidOfInvestment);
```

但这是错误的，因为0不是指针，尽管可被转换为指针，但最好还是使用转型(cast)：

```c++
// 建立一个null shared_ptr并以getRidOfInvestment为删除器
std::tr1::shared_ptr<Investment> pInv(static_cast<Investment*>(0), getRidOfInvestment);
```

因此，要实现createInvestment使它返回一个tr1::shared_ptr并带一函数为删除器，代码应如下：

```c++
std::tr1::shared_ptr<Investment> createInvestment()
{
    std::tr1::shared_ptr<Investment> retVal(static_cast<Investment*>(0), getRidOfInvestment);
    ...
    retVal = ...;	// 令retVal指向正确对象
    return retVal;
}
```

如果被pInv管理的原始指针可以在建立pInv之前先确定，那么将原始指针传给pInv构造函数比先将pInv初始化为nullptr再对它做一次赋值操作更好。

tr1::shared_ptr有一个很好的性质：它会自动使用它的“每个指针专属的删除器”，避免"cross-DLL problem"，即对象在DLL中被new创建，却在另一个DLL内被delete销毁。

> 18总结：
>
> - 好的接口容易被正确使用，不容易被误用。应当在自己设计的所有接口中努力达成这些性质。
> - 促进正确使用的办法包括接口的一致性，以及与内置类型的行为兼容。
> - 阻止误用的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。
> - tr1::shared_ptr支持定制型删除器(custom deleter)。这可防范DLL问题，可被用来自动解除互斥锁(mutexes)等等。

## 19：设计class犹如设计type

设计class时，我们还是type设计者。要考虑重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结等。

好的types有自然的语法、直观的语义，以及一或多个高效实现品。

设计高效的classes要面对以下问题：

- **新type的对象应如何被创建和销毁？**class的构造函数和析构函数以及内存分配函数和释放函数。
- **对象的初始化和对象的赋值该有什么样的差别？**class的构造函数和赋值操作符。
- **新type的对象如果被值传递，意味着什么？**copy构造函数
- **什么是新type的合法值？**对class的成员变量，通常只有某些数值集是有效的。决定了成员函数(特别是构造函数、赋值操作符和setter函数)。
- **你的新type需要配合某个继承图系吗？**继承时会受到所继承的classes的束缚，特别是它们的函数是virtual或non-virtual。若允许其他classes继承我们的class，还需考虑析构函数是否为virtual。
- **你的新type需要什么样的转换？**若要允许T1隐式转换为T2，就必须在T1内写一个类型转换函数(operator T2)或在T2内写一个non-explicit-one-argument(可被单一实参调用)的构造函数。若只允许explicit构造函数存在，那就得写出专门负责执行转换的函数，且不得为类型转换操作符或non-explicit-one-argument构造函数。
- **什么样的操作符和函数对此新type是合理的？**决定了该为class声明哪些函数，哪些是member函数，哪些否？
- **什么样的标准函数应该驳回？**声明为private的一些函数
- **谁该取用新type的成员？**决定哪个成员为public，哪个为protected，哪个为private。也决定哪一个class或function应为友元，以及将它们嵌套于另一个之内是否合理。
- **什么是新type的未声明接口**？
- **你的新type有多么一般化？**若要定义一整个types家族，不应用定义新class，而应定义一个新的class template。
- **你真的需要一个新type吗？**若只是定义新的derived class以便为既有class添加机能，可能单纯定义一或多个non-member函数或templates更能达到目标。

> 19总结：
>
> - class的设计就是type的设计。在定义一个新type前，请确定已经考虑过本守则覆盖的所有讨论主题。

## 20：宁以pass-by-reference-to-const替换pass-by-value

值传递时，函数参数都是以实参的副本为初值，而调用端获得的也是函数返回值的副本。这些副本由对象的copy构造函数产出，这使得值传递费时。考虑以下class继承体系：

```c++
class Person{
public:
    Person();
    virtual ~Person();
    ...
private:
    std::string name;
    std::string address;
};
class Student: public Person{
public:
    Student();
    ~Student();
private:
    std::string schoolName;
    std::string schoolAddress;
};
```

考虑以下代码，调用一需要Student实参并返回它是否有效的函数validateStudent。

```c++
bool validateStudent(Student s);		//函数以值传递方式接受学生
Student plato;							//柏拉图
bool platoIsOk = validateStudent(plato);//调用函数
```

对此函数，参数的传递成本是一次Student copy构造函数调用，一次Student析构函数调用。由于内有两个String对象，同时继承自内有两个String对象的Person对象，因此总成本是一次Student copy构造函数，一次Person copy构造函数，四次string copy构造函数，以及相对应的析构函数，即六次构造函数、六次析构函数！

更好的办法是：**采用const引用传递**：





可以合理假设pass-by-value并不昂贵的唯一对象是内置类型和STL的迭代器和函数对象。

> 20总结：
>
> - 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。
> - 以上规则不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value比较适当。

## 21：必须返回对象时，别妄想返回其reference

> 21总结：
>
> - 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated(分配到堆的)对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。守则4已为最后一点做出范本。

## 22：将成员变量声明为private

> 22总结：
>
> - 切记将成员变量声明为private，这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。
> - protected并不比public更具封装性。

## 23：宁以non-member、non-friend替换member函数

> 23总结：
>
> - 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。

## 24：若所有参数都需类型转换，请为此采用non-member函数

> 24总结：
>
> - 如果需要为某个函数的所有参数(包括被this指针所指的隐式参数)进行类型转换，那么这个函数必须是non-member。

## 25：考虑写出一个不抛异常的swap函数

> 25总结：
>
> - std::swap对自定义类型的效率不高时，请为自定义类型提供一个swap成员函数，并确定这个函数不抛出异常。
> - 如果我们提供了一个member swap，也应该提供一个non-member swap来调用前者。对于不是templates的classes，请特化std::swap。
> - 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何命名空间资格修饰。
> - 为用户定义类型进行std templates全特化是好的，但千万不要尝试在std内假如某些对std而言全新的东西。