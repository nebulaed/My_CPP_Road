# 设计与声明

## 18：让接口容易被正确使用，不易被误用

假设为一个用来表现日期的class设计构造函数：

```c++
class Date{
public:
    Date(int month, int day, int year);
};
```

这时客户可能传参时可能弄错月份、日期、年份的顺序，也可能传递一个无效的月份或天数。

这可以**通过导入新类型来预防。**类型系统是我们防范错误用法的好帮手。我们可以导入简单的外覆类型(wrapper types)来区别天数、月份和年份，然后于Date构造函数中使用这些类型：

```c++
struct Day{
explicit Day(int d): val(d) {}
int val;
};
struct Month{
explicit Month(int m): val(m) {}
int val;
};
struct Year{
explicit Year(int y): val(y) {}
int val;
};
class Date{
public:
    Date(const Month& m, const Day& d, const Year& y);
};
Date d(30, 3, 1995);	// Error!
Date d(Day(30), Month(3), Year(1995));	// Error!
Date d(Month(3), Day(30), Year(1995));	// OK!
```

令Day，Month，Year成为写得更成熟完善的class，是更好的选择。

现在有了正确的类型，限制其值也是合理的。比较安全的解法如下：

```c++
class Month{
public:
    static Month Jan() { return Month(1); }
    static Month Feb() { return Month(2); }
    ...
    static Month Dec() { return Month(12); }
    ...
private:
    explicit Month(int m);
};
Date d(Month::Mar(), Day(30), Year(1995));
```

这里以函数替换对象是为了符合守则4的要求。

预防客户错误的另一个办法是：限制类型内什么事可做，什么事不能做。