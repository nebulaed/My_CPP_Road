# 继承与面向对象设计

## 32：确定你的public继承塑模出is-a关系

以C++进行面向对象编程，最重要的一个规则是：public inheritance(公开继承)意味"is-a"(是一种)的关系。

> 32总结：
>
> - public继承意味着is-a。适用于基类身上的每一件事一定也适用于派生类身上，因为每一个派生类对象也都是一个基类对象。

## 33：避免遮掩继承而来的名称

> 33总结：
>
> - 派生类内的名称会遮掩基类内的名称。在public继承下这是不正确的。
> - 为了让被遮掩的名称重现，可使用using表达式或转交函数。

## 34：区分接口继承和实现继承

- 声明一个pure virtual函数的目的就是为了让派生类只继承函数接口。
- 声明impure virtual函数的目的，是让派生类继承该函数的接口和默认实现。
- 声明non-virtual函数的目的是为了令派生类继承函数的接口及一份强制性实现。

> 34总结：
>
> - 接口继承和实现继承不同。在public继承下，派生类总是继承基类的接口。
> - pure virtual函数只具体指定接口继承。
> - 简朴的impure virtual函数具体指定接口继承及默认实现继承。
> - non-virtual函数具体指定接口继承以及强制性实现继承。

## 35：考虑virtual函数以外的其他选择

## 36：绝不重新定义继承而来的non-virtual函数

> 36总结：
>
> - 绝对不要重新定义继承而来的non-virtual函数。

## 37：绝不重新定义继承而来的缺省参数值

> 37总结：
>
> - 绝对不要重新定义一个继承而来的默认参数值，因为默认参数值都是静态绑定，而virtual函数，唯一可以覆写的东西，却是动态绑定。

## 38：通过复合塑模出has-a或根据某物实现出

> 38总结：
>
> - 复合(composition)的意义和public继承完全不同。
> - 在应用域(application domain)，复合意味着has-a。在实现域(implementation domain)，复合意味着is-implemented-in-terms-of(根据某物实现出)。

## 39：明智而审慎地使用private继承

> 39总结：
>
> - private继承意味着is-implemented-in-terms-of(根据某物实现出)。它通常比复合的级别低。但是当派生类需要访问protected基类的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。
> - 和复合不同，private继承可以造成空基类最优化。这对致力于对象尺寸最小化的程序库开发者而言，非常重要。

## 40：明智而审慎地使用多重继承

> 40总结：
>
> - 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。
> - virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtual基类不带任何数据，将是最具实用价值的情况。
> - 多重继承的确有正当用途。其中一个情节涉及"public继承某个interface class"，和"private继承某个协助实现的class"的组合。