# 六、树

## 6.2 树的定义

树(tree)是n($n\geqslant0$)个结点的有限集。$n=0$时称为空树，在任意一颗非空树中：①有且仅有一个特定的称为根(root)的结点；②当$n>1$时，其余结点可分为m(m>0)个互不相交的有限集$T_1$、$T_2$、$ \cdots$、$T_m$，其中每一个集合本身又是一棵树，并且称为根的子树(subtree)。

结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。

结点的层次(level)从根开始定义起，根为第一层，某结点在l层，则其子树在l+1层。

树中结点的最大层次称为树的深度(depth)或高度。

## 6.4 树的存储结构 

### 6.4.1 双亲(单亲)表示法

单亲域、长子域、右兄弟域

### 6.4.2 孩子表示法

把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

改进版：单亲孩子表示法

### 6.4.3 孩子兄弟表示法

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

这种表示法最大好处是把一棵复杂的树编程了一棵二叉树。

## 6.5 二叉树的定义

二叉树(binary tree)是n($n\geqslant0$)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

### 6.5.1 二叉树的特点

- 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。不是只有两棵，而是最多有两棵。
- 左子树和右子树是有顺序的，次序不能颠倒。
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

二叉树具有以下五种基本形态：

1. 空二叉树。
2. 只有一个根结点。
3. 根结点只有左子树。
4. 根结点只有右子树。
5. 根结点既有左子树又有右子树。

### 6.5.2 特殊二叉树

#### 6.5.2.1 斜树

所有的结点都只有左子树的二叉树叫做左斜树。所有结点都只有右子树的二叉树叫右斜树。

#### 6.5.2.2 满二叉树

在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称	为满二叉树。

满二叉树的特点有：

1. 叶子只能出现在最下一层。
2. 非叶子结点的度一定是2。
3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

#### 6.5.2.3 完全二叉树

对一颗具有n个结点的二叉树按层序编号，如果编号为i($1\leqslant i\leqslant n$)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

完全二叉树的特点：

1) 叶子结点只能出现在最下两层

2) 最下层的叶子一定集中在左部连续位置

3) 倒数第二层，若有叶子结点，一定都在右部连续位置。

4) 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。

5) 同样结点数的二叉树，完全二叉树的深度最小。

## 6.6 二叉树的性质

性质1：在二叉树的第i层至多有$2^{i-1}$个结点($i\geqslant 1$)。

性质2：深度为k的二叉树至多有$2^k-1$个结点$(k\geqslant 1$)。

性质3：对任何一棵二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。

性质4：具有n个结点的完全二叉树的深度为$\lfloor \log_2n\rfloor+1$($\lfloor x\rfloor$表示不大于x的最大整数)。

性质5：如果对一棵有n个结点的完全二叉树(其深度为$\lfloor \log_2 n\rfloor+1$)的结点按层序编号(从第1层到第$\lfloor \log_2n\rfloor+1$层，每层从左到右)，对任一结点i($1\leqslant i \leqslant n$)有：

(1) 如果$i=1$，则结点i是二叉树的根，无双亲；如果$i>1$，则其单亲是结点$\lfloor i/2\rfloor$。

(2) 如果$2i>n$，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i。

(3) 如果$2i+1>n$，则结点i无右孩子，否则其右孩子是结点2i+1。

## 6.7 二叉树的存储结构

### 6.7.1 二叉树的顺序存储结构

顺序存储结构一般只用于完全二叉树，否则会造成存储空间的浪费。

### 6.7.2 二叉链表

二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域很自然。称这样的列表为二叉链表。

若有需要，可以再增加一个指向双亲的指针域，那样称为三叉链表。

## 6.8 遍历二叉树

### 6.8.1 二叉树的遍历原理

二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。

### 6.8.2 二叉树的遍历方法

**1.前序遍历**

规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

**2.中序遍历**

规则是若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。

**3.后序遍历**

规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 

**4.层序遍历**

规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上到下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

### 6.8.3 前序遍历方法

```c++
/* 初始条件: 二叉树T存在 */
/* 操作结果: 前序递归遍历T */
void PreOrderTraverse(BiTree T)
{ 
	if(T==NULL)
		return;
	printf("%c",T->data);/* 显示结点数据，可以更改为其它对结点操作 */
	PreOrderTraverse(T->lchild); /* 再先序遍历左子树 */
	PreOrderTraverse(T->rchild); /* 最后先序遍历右子树 */
}
```

### 6.8.4 中序遍历算法

```c++
/* 初始条件: 二叉树T存在 */
/* 操作结果: 中序递归遍历T */
void InOrderTraverse(BiTree T)
{ 
	if(T==NULL)
		return;
	InOrderTraverse(T->lchild); /* 中序遍历左子树 */
	printf("%c",T->data);/* 显示结点数据，可以更改为其它对结点操作 */
	InOrderTraverse(T->rchild); /* 最后中序遍历右子树 */
}
```

### 6.8.5 后序遍历算法

```c++
/* 初始条件: 二叉树T存在 */
/* 操作结果: 后序递归遍历T */
void PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return;
	PostOrderTraverse(T->lchild); /* 先后序遍历左子树  */
	PostOrderTraverse(T->rchild); /* 再后序遍历右子树  */
	printf("%c",T->data);/* 显示结点数据，可以更改为其它对结点操作 */
}
```

### 6.8.6 推导遍历结果

已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。

已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。

已知前序和后序遍历，是不能确定一棵二叉树的。

## 6.9 二叉树的建立

将二叉树中每个结点的空指针引出一个虚结点，处理后的二叉树称为扩展二叉树。

```c++
/* 按前序输入二叉树中结点的值（一个字符） */
/* #表示空树，构造二叉链表表示二叉树T。 */
void CreateBiTree(BiTree *T)
{ 
	TElemType ch;
	
	/* scanf("%c",&ch); */
	ch=str[treeIndex++];

	if(ch=='#') 
		*T=NULL;
	else
	{
		*T=(BiTree)malloc(sizeof(BiTNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)->data=ch; /* 生成根结点 */
		CreateBiTree(&(*T)->lchild); /* 构造左子树 */
		CreateBiTree(&(*T)->rchild); /* 构造右子树 */
	}
}
```

## 6.10 线索二叉树

### 6.10.1 线索二叉树的原理

指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。

线索二叉树，等于是把一棵二叉树转变为了一个双向链表，这样就为插入删除结点、查找某个结点带来了方便。

对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化。

为了搞清楚某一结点的lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，在每个结点增设两个标志域ltag和rtag，它们只存放0或1的布尔型变量。

- ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。
- rtag为0时指向该结点的右孩子，为1时指向该结点的后继。

### 6.10.2 线索二叉树结构的实现

线索化的过程就是在遍历的过程中修改空指针的过程。

遍历的代码如下：

```c++
Status visit(TElemType e)
{
	printf("%c ",e);
	return OK;
}

/* 中序遍历二叉线索树T(头结点)的非递归算法 */
Status InOrderTraverse_Thr(BiThrTree T)
{ 
	BiThrTree p;
	p=T->lchild; /* p指向根结点 */
	while(p!=T)
	{ /* 空树或遍历结束时,p==T */
		while(p->LTag==Link)
			p=p->lchild;
		if(!visit(p->data)) /* 访问其左子树为空的结点 */
			return ERROR;
		while(p->RTag==Thread&&p->rchild!=T)
		{
			p=p->rchild;
			visit(p->data); /* 访问后继结点 */
		}
		p=p->rchild;
	}
	return OK;
}
```

这等于是一个链表的扫描，时间复杂度为O(n)。

如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。

## 6.11 树、森林与二叉树的转换

### 6.11.1 树转换为二叉树

步骤：

1. 加线。在所有兄弟结点之间加一条连线。
2. 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。
3. 层次调整。第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。

### 6.11.2 森林转换为二叉树

步骤：

1. 把每个树转换为二叉树。
2. 第一棵二叉树不动，从第二棵二叉树开始，依次将后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。

### 6.11.3 二叉树转换为树

二叉树转换为树就是树转换为二叉树的逆过程。

### 6.11.4 二叉树转换为森林

判断一颗二叉树能够转换成一棵树还是森林，标准很简单，就是看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。

### 6.11.5 树与森林的遍历

树的遍历有两种方式：

- 先根遍历树。即先访问树的根结点，然后依次先根遍历根的每棵子树。
- 后根遍历。即先依次后根遍历每棵子树，然后再访问根结点。

森林的遍历也分为两种方式。

- 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。
- 后序遍历：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。

森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。

## 6.12 哈夫曼树及其应用

### 6.12.2 哈夫曼树的定义与原理

从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。

树的路径长度就是从树根到每一结点的路径长度之和。

若考虑带权结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。

带权路径长度WPL最小的二叉树称做哈夫曼树。

### 6.12.3 哈夫曼编码

若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。

一般地，设需要编码的字符集为$\{d_1,d_2,\cdots,d_n\}$，各个字符在电文中出现的次数或频率结合$\{w_1,w_2,\cdots,w_n\}$，以$d_1$，$d_2$，$\cdots$，$d_n$作为叶子结点，以$w_1$，$w_2$，$\cdots$，$w_n$作为相应叶子结点的权值来构造一棵哈夫曼树。规定哈夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是哈夫曼编码。

