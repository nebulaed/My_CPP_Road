# 八、查找

## 8.3 顺序表查找

顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个或最后一个记录开始，逐个进行记录的关键字和给定值比较，若相等，则查找成功；如果直到最后一个(或第一个)记录，都不等，则表中没有所查记录，查找失败。

### 8.3.1 顺序表查找算法

顺序查找算法如下：

```c++
/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */
int Sequential_Search(int *a,int n,int key)
{
	int i;
	for(i=1;i<=n;i++)
	{
		if (a[i]==key)
			return i;
	}
	return 0;
}
```

### 8.3.2 顺序表查找优化

```c++
/* 有哨兵顺序查找 */
int Sequential_Search2(int *a,int n,int key)
{
	int i;
	a[0]=key;
	i=n;
	while(a[i]!=key)
	{
		i--;
	}
	return i;
}
```

时间复杂度为O(n)。

## 8.4 有序表查找

### 8.4.1 折半查找

折半查找(Binary Search)技术，又称为二分查找。前提是线性表中的记录必须是关键码有序，线性表必须采用顺序存储。

折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直至查找成功，或所有查找区域无记录，查找失败为止。

折半查找算法的时间复杂度为O(log n)。

### 8.4.2 插值查找

$$
\text{mid} = \frac{\text{low}+\text{high}}{2}=\text{low}+\frac12(\text{high}-\text{low})
$$

mid等于最低下标low加上最高下标high与low的差的一半。将$\dfrac12$改进后，有：
$$
\text{mid} = \text{low}+\frac{\text{key}-\text{a[low]}}{\text{a[high]}-\text{a[low]}}(\text{high}-\text{low})
$$
插值查找(Interpolation Search)是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式$\frac{\text{key}-\text{a[low]}}{\text{a[high]}-\text{a[low]}}$。

该算法时间复杂度也是O(log n)。但对于表长较大，关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找好得多。

### 8.4.3 斐波那契查找

斐波那契查找(Fibonacci Search)，利用黄金分割原理来实现。

斐波那契查找算法的核心在于：

① 当key=a[mid]时，查找成功。

② 当key<a[mid]时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个。

③ 当key>a[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。

斐波那契查找的时间复杂度也为O(log n)。

> 三种有序表的查找本质上是分隔点的选择不同，各有优劣。

## 8.5 线性索引查找

线性索引就是将索引项集合组织为线性结构，也称为索引表。

### 8.5.1 稠密索引

稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，对稠密索引整个索引表来说，索引项一定是按照关键码有序排列的。

### 8.5.2 分块索引

分块有序，是把数据集的记录分成若干块，且这些块需要满足以下两个条件：

- 块内无序
- 块间有序

对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫分块索引。

分块索引的索引项结构分三个数据项：

- 最大关键码
- 存储块中的记录个数。
- 指向块首数据元素的指针。

在分块索引表中查找，分两步：

1. 在分块索引表中查找要查关键字所在的块，由于快间有序，可用折半、插值等算法得到结果。
2. 根据块首指针找到相应的块，并在块中顺序查找关键码，因为块中可以是无序的，因此只能顺序查找。

### 8.5.3 倒排索引

索引项的通用结构是：

- 次关键码
- 记录号表

其中记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或者是该记录的主关键字)。这样的索引方法就是倒排索引(inverted index)。

倒排索引的优点是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。缺点是记录号不定长，若对多篇文章所有单词都建立倒排索引，每个单词都将对应相当多的文章编号，维护困难，插入和删除操作都需要做相应处理。

## 8.6 二叉排序树

二叉排序树(Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。
- 它的左、右子树也分别为二叉排序树。

对二叉排序树进行中序遍历时，可得到有序的序列。

### 8.6.1 二叉排序树的查找操作

```c++
/* 递归查找二叉排序树T中是否存在key, */
/* 指针f指向T的双亲，其初始调用值为NULL */
/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */
/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */
Status SearchBST(BiTree T, int key, BiTree f, BiTree *p) 
{  
	if (!T)	/*  查找不成功 */
	{ 
		*p = f;  
		return FALSE; 
	}
	else if (key==T->data) /*  查找成功 */
	{ 
		*p = T;  
		return TRUE; 
	} 
	else if (key<T->data) 
		return SearchBST(T->lchild, key, T, p);  /*  在左子树中继续查找 */
	else  
		return SearchBST(T->rchild, key, T, p);  /*  在右子树中继续查找 */
}
```

### 8.6.2 二叉排序树的插入操作

```c++
/*  当二叉排序树T中不存在关键字等于key的数据元素时， */
/*  插入key并返回TRUE，否则返回FALSE */
Status InsertBST(BiTree *T, int key) 
{  
	BiTree p,s;
	if (!SearchBST(*T, key, NULL, &p)) /* 查找不成功 */
	{
		s = (BiTree)malloc(sizeof(BiTNode));
		s->data = key;  
		s->lchild = s->rchild = NULL;  
		if (!p) 
			*T = s;			/*  插入s为新的根结点 */
		else if (key<p->data) 
			p->lchild = s;	/*  插入s为左孩子 */
		else 
			p->rchild = s;  /*  插入s为右孩子 */
		return TRUE;
	} 
	else 
		return FALSE;  /*  树中已有关键字相同的结点，不再插入 */
}
```

### 8.6.3 二叉排序树的删除操作

对删除结点三种情况的分析：

- 叶子结点；
- 仅有左或右子树的结点；
- 左右子树都有的结点。

```c++
/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */
/* 并返回TRUE；否则返回FALSE。 */
Status DeleteBST(BiTree *T,int key)
{ 
	if(!*T) /* 不存在关键字等于key的数据元素 */ 
		return FALSE;
	else
	{
		if (key==(*T)->data) /* 找到关键字等于key的数据元素 */ 
			return Delete(T);
		else if (key<(*T)->data)
			return DeleteBST(&(*T)->lchild,key);
		else
			return DeleteBST(&(*T)->rchild,key);
		 
	}
}
```

```c++
/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */
Status Delete(BiTree *p)
{
	BiTree q,s;
	if((*p)->rchild==NULL) /* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */
	{
		q=*p; *p=(*p)->lchild; free(q);
	}
	else if((*p)->lchild==NULL) /* 只需重接它的右子树 */
	{
		q=*p; *p=(*p)->rchild; free(q);
	}
	else /* 左右子树均不空 */
	{
		q=*p; s=(*p)->lchild;
		while(s->rchild) /* 转左，然后向右到尽头（找待删结点的前驱） */
		{
			q=s;
			s=s->rchild;
		}
		(*p)->data=s->data; /*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */
		if(q!=*p)
			q->rchild=s->lchild; /*  重接q的右子树 */ 
		else
			q->lchild=s->lchild; /*  重接q的左子树 */
		free(s);
	}
	return TRUE;
}
```

### 8.6.4 二叉排序树总结

二叉排序树的插入和删除时间性能较好。

二叉排序树的查找性能取决于二叉排序树的形状。

因此希望二叉排序树是比较平衡的，深度与完全二叉树相同，均为$\lfloor \log_2n\rfloor+1$，则查找的时间复杂度为O(log n)。

## 8.7 平衡二叉树(AVL树)

平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。

将二叉树上结点的左子树高度减去右子树高度的值称为平衡因子BF(Balance Factor)。平衡二叉树上所有结点的平衡因子只可能是-1，0和1。

距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。

### 8.7.1 平衡二叉树的实现原理

平衡二叉树构建的基本思想是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的连接关系，进行相应的旋转，使之称为新的平衡子树。

当最小不平衡子树根结点的平衡因子BF大于1时，右旋，小于-1左旋，插入节点后，最小不平衡子树的BF与它的子树的BF符号相反时，需要对结点先进行一次旋转使得符号相同后，再反向旋转一次才能完成平衡操作。

### 8.7.2 平衡二叉树的实现算法

右旋操作：

```c++
/* 对以p为根的二叉排序树作右旋处理， */
/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */
void R_Rotate(BiTree *P)
{ 
	BiTree L;
	L=(*P)->lchild; /*  L指向P的左子树根结点 */ 
	(*P)->lchild=L->rchild; /*  L的右子树挂接为P的左子树 */ 
	L->rchild=(*P);
	*P=L; /*  P指向新的根结点 */ 
}
```

左旋操作：

```c++
/* 对以P为根的二叉排序树作左旋处理， */
/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */
void L_Rotate(BiTree *P)
{ 
	BiTree R;
	R=(*P)->rchild; /*  R指向P的右子树根结点 */ 
	(*P)->rchild=R->lchild; /* R的左子树挂接为P的右子树 */ 
	R->lchild=(*P);
	*P=R; /*  P指向新的根结点 */ 
}
```

若我们需要查找的集合本身没有顺序，在频繁查找的同时也需要经常进行插入和删除操作，就需要平衡二叉树，此时查找时间复杂度为O(log n)，插入和删除也为O(log n)。

## 8.8 多路查找树(B树)

多路查找树(Multi-Way Search Tree)，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。

这里每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。有4种特殊形式：2-3树、2-3-4树、B树和B+树。

### 8.8.1 2-3树

#### 1. 2-3树的插入实现

2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（称为2结点）或三个孩子（称为3结点）。

一个2结点包含一个元素和两个孩子(或没有孩子)，2结点要么没有孩子，要么有两个孩子。

一个3结点包含一小一大两个元素和三个孩子(或没有孩子)，3结点要么没有孩子，要么有3个孩子。

2-3树插入可分为三种情况：

1. 空树，插入一个2结点即可
2. 插入结点到一个2结点的叶子上，只需将其升级为3结点。
3. 往3结点插入一个新元素，需要将该3结点拆分，将树中两元素或插入元素的三者中选择其一向上移动一层。

若2-3树插入的传播效应导致根结点的拆分，则树的高度就会增加。

#### 2. 2-3树的删除实现

### 8.8.2 2-3-4树

2-3-4树是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大3个元素和4个孩子(或没有孩子)。

### 8.8.3 B树

B树(B-tree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。

结点最大的孩子数目称为B树的阶(order)。2-3树是3阶B树，2-3-4树是4阶B树。

一个m阶的B树具有如下属性：

- 如果根结点不是叶结点，则其至少有两棵子树。
- 每一个非根的分支结点都有k-1个元素和k个孩子，$\lceil m/2\rceil\leqslant k\leqslant m$。每一个叶子结点n都有k-1个元素。其中$\lceil m/2\rceil\leqslant k\leqslant m$。
- 所有叶子结点都位于同一层次。
- 所有分支结点包含下列信息数据(n，A~0~，K~1~，A~1~，K~2~，A~2~，…，K~n~，A~n~)，其中：K~i~(i=1,2,...,n)为关键字，且K~i~<K~i+1~(i=1,2,...,n-1)；A~i~(i=1,2,...,n)为指向子树根结点的指针，且指针A~i-1~所指子树中所有结点的关键字均小于K~i~(i=1,2,...,n)，A~n~所指子树中所有结点的关键字均大于K~n~，n($\lceil m/2\rceil-1\leqslant n\leqslant m-1$)为关键字的个数(或n+1为子树的个数)。

对n个关键字的m阶B树进行查找，从根结点到关键字结点的路径上涉及的结点数不超过$\log_{\lceil \frac m2\rceil}\left(\dfrac{n+1}{2}\right)+1$。

### 8.8.4 B+树

B树的中序遍历必须在硬盘的页面之间进行多次访问。

为解决所有元素遍历等基本问题，在原有的B树结构基础上，加上了新的元素组织方式，就是B+树。

B+树是应文件系统所需而出的一种B树的变形树。

在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者(叶子结点)中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。

一棵m阶的B+树和m阶的B树的差异在于：

- 有n棵子树的结点中包含有n个关键字。
- 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- 所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小)关键字。

B+树最大的好处在于，如果要随机查找，就从根结点出发，与B树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。

如果需要从最小关键字进行从小到大的顺序查找，就可以从最左端的叶子结点出发，不经过分支结点，而是沿着指向下一叶子的指针就可遍历所有的关键字。

B+树的结构特别适合带有范围的查找。

B+树的插入、删除与B树类似，只不过插入和删除的元素都在叶子节点进行而已。

## 8.9 散列表查找(哈希表)概述

通过某个函数f，使得

存储位置=f(关键字)

这样就可以通过查找关键字不需要比较就可获得需要记录的存储位置。这就是散列技术。

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。

对应关系f称为散列函数，又称为哈希(Hash)函数。

采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash Table)。关键字对应的记录存储位置称为散列地址或哈希地址。

### 8.9.2 散列表查找步骤

散列过程是两步：

1. 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
2. 查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。

散列技术既是一种存储方法，也是一种查找方法。

散列是面向查找的存储结构。

散列技术最适合的求解问题就是查找与给定值相等的记录。

设计一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。

两个关键字key1$\neq$key2，但却有f(key1)=f(key2)，这种现象称为冲突(collision)，并把key1和key2称为这个散列函数的同义词(synonym)。

## 8.10 散列函数的构造方法

设计散列函数原则：

1. 计算简单
2. 散列地址分布均匀

### 8.10.1 直接定址法

取关键字的某个线性函数值为散列地址。即

f(key)=a×key+b(a、b为常数)

优点是简单、均匀，不会产生冲突，问题是需要事先知道关键字的分布情况，适合查找表较小且连续的情况。虽然简单但并不常用。

### 8.10.2 数字分析法

抽取方法是使用关键字的一部分来计算散列存储位置的方法，在散列函数中是常用到的手段。

数字分析法通常适合处理关键字位数较多的情况。若事先知道关键字的分布且关键字的若干位分布较均匀，可以考虑用这个方法。

### 8.10.3 平方取中法

假设关键字是1234，那么平方就是1522756，再抽取中间3位就是227，用做散列地址。平方取中法适合不知道关键字分布，而位数又不是很多的情况。

### 8.10.4 折叠法

折叠法是将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。

折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。

### 8.10.5 除留余数法

此方法为==最常用==的构造散列函数的方法。对于散列表长为m的散列函数公式为：
$$
f(\text{key})=\text{key}\mod{p} (p\leqslant m)
$$
mod是取模(求余数)的意思。

若散列表表长为m，通常p为小于或等于表长(最好接近m)的最小质数或不包含小于20质因子的合数。

### 8.10.6 随机数法

选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f(key)=random(key)。

这里random是随机函数，当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。

采用不同散列安徽念书是考虑的因素：

1. 计算散列地址所需的实践
2. 关键字的长度
3. 散列表的大小
4. 关键字的分布情况
5. 记录查找的频率

## 8.11 处理散列冲突的方法

### 8.11.1 开放定址法

开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
$$
f_i(\text{key})=(f(\text{key})+d_i)\mod{m} (d_i=1,2,3,...,m-1)
$$
$d_i$表示试探值，若$d_i=1$散列地址不冲突则选1，否则$d_i=2$，这样逐一试探。

这种解决冲突的开放定址法称为线性探测法。

本来不是同义词却需要争夺一个地址的现象称为堆积。

可以改进$d_i=1^2,-1^2,2^2,-2^2,\cdots,q^2,-q^2(q\leqslant m/2)$，这样就可以双向寻找可能的空位置。增加平方运算的目的是不让关键字都聚集在某一块区域，称这种方法为二次探测法。
$$
f_i(\text{key})=(f(\text{key})+d_i)\mod{m} (d_i=1^2,-1^2,2^2,-2^2,\cdots,q^2,-q^2(q\leqslant m/2))
$$
还有一种方法是，在冲突时，对于位移量$d_i$采用随机函数计算得到，称之为随机探测法。这里的随机时伪随机数。
$$
f_i(\text{key})=(f(\text{key})+d_i)\mod{m} (d_i是一个随机数列)
$$
总之，开放定址法只要在散列表未填满时，总能找到不发生冲突的地址。

### 8.11.2 再散列函数法

对散列表事先准备多个散列函数：
$$
f_i(\text{key})=\text{RH}_i(\text{key})(i=1,2,\cdots,k)
$$
这里的RH~i~就是不同的散列函数。每当发生散列地址冲突时，就换一个散列函数计算。

### 8.11.3 链地址法

将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。

链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障，同时也带来了查找时需要遍历单链表的性能损耗。

### 8.11.4 公共溢出区法

为所有冲突的关键字建立一个公共的溢出区来存放。

在查找时，对给定值通过散列函数计算散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。

## 8.12 散列表查找的实现

### 8.12.1 散列表查找的算法实现

HashTable：散列表结构，elem：动态数组

```c++
#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12 /* 定义散列表长为数组的长度 */
#define NULLKEY -32768 

typedef struct
{
   int *elem; /* 数据元素存储基址，动态分配数组 */
   int count; /*  当前数据元素个数 */
}HashTable;
```

散列表的初始化：

```c++
/* 初始化散列表 */
Status InitHashTable(HashTable *H)
{
	int i;
	m=HASHSIZE;
	H->count=m;
	H->elem=(int *)malloc(m*sizeof(int));
	for(i=0;i<m;i++)
		H->elem[i]=NULLKEY; 
	return OK;
}
```

散列函数：

```c++
/* 散列函数 */
int Hash(int key)
{
	return key % m; /* 除留余数法 */
}
```

散列表的插入：

```c++
/* 插入关键字进散列表 */
void InsertHash(HashTable *H,int key)
{
	int addr = Hash(key); /* 求散列地址 */
	while (H->elem[addr] != NULLKEY) /* 如果不为空，则冲突 */
	{
		addr = (addr+1) % m; /* 开放定址法的线性探测 */
	}
	H->elem[addr] = key; /* 直到有空位后插入关键字 */
}
```

散列表的查找：

```c++
/* 散列表查找关键字 */
Status SearchHash(HashTable H,int key,int *addr)
{
	*addr = Hash(key);  /* 求散列地址 */
	while(H.elem[*addr] != key) /* 如果不为空，则冲突 */
	{
		*addr = (*addr+1) % m; /* 开放定址法的线性探测 */
		if (H.elem[*addr] == NULLKEY || *addr == Hash(key)) /* 如果循环回到原点 */
			return UNSUCCESS;	/* 则说明关键字不存在 */
	}
	return SUCCESS;
}
```

### 8.12.2 散列表查找的性能分析

若没有冲突，散列查找时间复杂度为O(1)。

实际散列查找的平均查找长度取决于：

1. 散列函数是否均匀(由于不同散列函数对同一组随机的关键字，产生冲突的可能性是相同的，可以不考虑该因素)
2. 处理冲突的方法(链地址法优于二次探测优于线性探测)
3. 散列表的装填因子(装填因子$\alpha$=填入表中的记录个数/散列表长度)。$\alpha$标志着散列表的装满程度，填入表中的记录越多，$\alpha$越大，产生冲突的可能性越大。