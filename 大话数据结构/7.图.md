# 七、图

## 7.2 图的定义

图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成的，通常表示为G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

- 图中数据元素，称为顶点(Vert
- 图结构中不允许没有顶点，若V是顶点的集合，强调顶点集合V有穷非空。
- 图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示。

### 7.2.1 各种图的定义

无向边：若顶点$v_i$和$v_j$之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对($v_i$，$v_j$)来表示。

若图中任意两个顶点之间的边都是无向边，则称该图为无向图。

有向边：若从顶点$v_i$到$v_j$的边有方向，则称这条边为有向边，也称为弧(Arc)。用有序偶<$v_i$,$v_j$>来表示，$v_i$称为弧尾(Tail)，$v_j$称为弧头(Head)。

若图中任意两个顶点之间的边都是有向边，则称该图为有向图。

无向边用小括号()表示，而有向边则是用尖括号<>表示。

在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。

在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有$\dfrac{n \times (n-1)}{2}$条边。

在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有$n\times (n-1)$条边。

对具有n个顶点和e条边数的图，无向图$0\leqslant e \leqslant n(n-1)/2$，有向图$0\leqslant e \leqslant n(n-1)$。

有很少条边或弧的图称为稀疏图，反之称为稠密图。

与图的边或弧相关的数叫做权(Weight)。这种带权的图通常称为网(Network)。

假设有两个图G=(V,\{E\})和G'=(V',{E'})，如果V'$\subseteq$V且E'$\subseteq$E，则称G'为G的子图(Subgraph)。

### 7.2.2 图的顶点与边间的关系

对于无向图G=(V,\{E\})​，如果边(v,v')$\in$E，则称顶点v和v'互为邻接点(Adjacent)，即v和v'相邻接。边(v,v')依附(incident)于顶点v和v'，或者说(v,v')与顶点v和v'相关联。顶点v的度(Degree)是和v相关联的边的数目，记为TD(v)。

## 7.4 图的存储结构

### 7.4.1 邻接矩阵

图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。

无向图的邻接矩阵是一个对称矩阵。对称矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的。

n个顶点和e条边的无向网图的创建，时间复杂度为O(n+$n^2$+e)，其中对邻接矩阵G.arc的初始化耗费了O($n^2$)的时间。

### 7.4.2 邻接表

数组与链表相结合的存储方式称为邻接表(Adjacency List).

邻接表的处理方法如下：

1. 图中顶点用一个一维数组存储。顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。
2. 图中每个顶点$v_i$的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点$v_i$的边表，有向图则称为顶点$v_i$作为弧尾的出边表。

有向图可以有逆邻接表，即对每个顶点$v_i$都建立一个链接为$v_i$为弧头的表。

n个顶点e条边的无向图邻接表的时间复杂度为O(n+e)。

### 7.4.3 十字链表

对于有向图来说，邻接表是有缺陷的。只关心了出度问题，逆邻接表只解决了入度的问题。把邻接表和逆邻接表结合起来，即十字链表(Orthogonal List)。

顶点表结点结构如下：



十字链表的好处就是既容易找到以$v_i$为尾的弧，也容易找到以$v_i$为头的弧，容易求得顶点的出度和入度，创建图算法的时间复杂度与邻接表相同。

### 7.4.4 邻接多重表

无向图用邻接表表示的缺点在于对边进行操作比较麻烦，需操作两个结点。

邻接多重表和邻接表的差别仅在于同一条边在邻接表中用两个结点表示，在邻接多重表中只有一个结点。

### 7.4.5 边集数组

边集数组是由两个一维数组构成的。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成。

## 7.5 图的遍历

从图中某一顶点出发访遍图中其余顶点，且使每个顶点仅被访问依次，这一过程叫做图的遍历(Traversing Graph)。

### 7.5.1 深度优先遍历

深度优先遍历(Depth First Search)，简称为DFS。

它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

对于n个顶点e条边的图，邻接矩阵的DFS的时间复杂度为O($n^2$)；邻接表的DFS时间复杂度为O(n+e)。

### 7.5.2 广度优先遍历

广度优先遍历(Breadth First Search)，又称为广度优先搜索，简称BFS。

图的深度优先遍历和广度优先遍历时间复杂度是一样的。

## 7.6 最小生成树

构造连通网的最小代价生成树称为最小生成树(Minimum Cost Spanning Tree)。

找连通网的最小生成树，经典的两种算法：普里姆算法、克鲁斯卡尔算法。

### 7.6.1 普里姆(Prim)算法

算法的时间复杂度为O($n^2$)。

### 7.6.2 克鲁斯卡尔(Kruskal)算法

假设N=(V,{E})是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。

此算法的Find函数由边数e决定，时间复杂度为O($\log e$)，而外面有一个for循环e次，所以克鲁斯卡尔算法的时间复杂度为O(e$\log e$)。

## 7.7 最短路径

### 7.7.1 迪杰斯特拉(Dijkstra)算法

```c++
/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    
/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  
void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)
{    
	int v,w,k,min;    
	int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */
	for(v=0; v<G.numVertexes; v++)    /* 初始化数据 */
	{        
		final[v] = 0;			/* 全部顶点初始化为未知最短路径状态 */
		(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */
		(*P)[v] = -1;				/* 初始化路径数组P为-1  */       
	}

	(*D)[v0] = 0;  /* v0至v0路径为0 */  
	final[v0] = 1;    /* v0至v0不需要求路径 */        
	/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   
	for(v=1; v<G.numVertexes; v++)   
	{
		min=GRAPH_INFINITY;    /* 当前所知离v0顶点的最近距离 */        
		for(w=0; w<G.numVertexes; w++) /* 寻找离v0最近的顶点 */    
		{            
			if(!final[w] && (*D)[w]<min)             
			{                   
				k=w;                    
				min = (*D)[w];    /* w顶点离v0顶点更近 */            
			}        
		}        
		final[k] = 1;    /* 将目前找到的最近的顶点置为1 */
		for(w=0; w<G.numVertexes; w++) /* 修正当前最短路径及距离 */
		{
			/* 如果经过v顶点的路径比现在这条路径的长度短的话 */
			if(!final[w] && (min+G.arc[k][w]<(*D)[w]))   
			{ /*  说明找到了更短的路径，修改D[w]和P[w] */
				(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               
				(*P)[w]=k;        
			}       
		}   
	}
}
```

找到一个顶点到图中其他所有顶点的最短路径的Dijkstra算法的时间复杂度为O($n^2$)。

求所有顶点到图中其他所有顶点的最短路径的Dijkstra算法的时间复杂度为O($n^3$)。

### 7.7.2 弗洛伊德(Floyd)算法

***D***代表顶点到顶点的最短路径权值和的矩阵，***P***代表对应顶点的最短路径的前驱矩阵，用来存储路径。

未分析任何结点的初始***D***表示为$\boldsymbol{D}^{-1}$，同理初始***P***为$\boldsymbol{P}^{-1}$。

求得所有顶点经过v~0~后到达其他顶点的最短路径后，更新***D***，得到$\boldsymbol{D}^{0}$，同理得到$\boldsymbol{P}^{0}$。即
$$
\boldsymbol{D}^0[v][w]=\min\{\boldsymbol{D}^{-1}[v][w],\boldsymbol{D}^{-1}[v][0]+\boldsymbol{D}^{-1}[0][w]\}
$$

```c++
/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */    
void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)
{    
	int v,w,k;    
	for(v=0; v<G.numVertexes; ++v) /* 初始化D与P */  
	{        
		for(w=0; w<G.numVertexes; ++w)  
		{
			(*D)[v][w]=G.arc[v][w];	/* D[v][w]值即为对应点间的权值 */
			(*P)[v][w]=w;				/* 初始化P */
		}
	}
	for(k=0; k<G.numVertexes; ++k)   
	{
		for(v=0; v<G.numVertexes; ++v)  
		{        
			for(w=0; w<G.numVertexes; ++w)    
			{
				if ((*D)[v][w]>(*D)[v][k]+(*D)[k][w])
				{/* 如果经过下标为k顶点路径比原两点间路径更短 */
					(*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */
					(*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */
				}
			}
		}
	}
}
```

求所有顶点到图中其他所有顶点的最短路径的Floyd算法的时间复杂度同样为O($n^3$)。

## 7.8 拓扑排序

在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网(Activity On Vertex Network)。

设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v~1~，v~2~，$\cdots$，v~n~，满足若从顶点v~i~到v~j~有一条路径，则在顶点序列中顶点v~i~必在顶点v~j~之前。则称这样的顶点序列为一个拓扑序列。

拓扑排序，其实就是对一个有向图构造拓扑序列的过程。

### 7.8.2 拓扑排序算法

对AOV网进行拓扑排序的基本思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或AOV网中不存在入度为0的顶点为止。

对一个具有n个顶点e条弧的AOV网来说，整个算法的时间复杂度为O(n+e)。

## 7.9 关键路径

在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为AOE网(Activity On Edge Network)。

把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。

### 7.9.1 关键路径算法的原理

为求关键路径，需定义以下几个参数：

- 事件的最早发生时间etv(earliest time of vertex)：即顶点v~k~的最早发生时间。
- 事件的最晚发生时间ltv(latest time of vertex)：即顶点v~k~的最晚发生时间。
- 活动的最早开工时间ete(earliest time of edge)：即弧a~k~的最早发生时间。
- 活动的最晚开工时间lte(latest time of edge)：即弧a~k~的最晚发生时间。

由1和2可求得3和4，再根据ete[k]是否与lte[k]相等来判断a~k~是否是关键活动。

### 7.9.2 关键路径算法

计算顶点v~k~即求etv[k]的最早发生时间的公式是：
$$
\text{etv}[k]=\begin{cases} 0, & 当k=0时 \\\max\{\text{etv}[i]+\text{len}<v_i,v_k>\} & 当k\neq0且<v_i,v_k>\in P[k]时 \end{cases}
$$
计算顶点v~k~即求ltv[k]的最晚发生时间的公式是：
$$
\text{ltv}[k]=\begin{cases} \text{etv}[k], & 当k=n-1时 \\\min\{\text{ltv}[j]-\text{len}<v_k,v_j>\} & 当k<n-1且<v_k,v_j>\in S[k]时 \end{cases}
$$
求关键路径算法的时间复杂度为O(n+e)。

