# 一、数据结构储论

## 1.5 逻辑结构与物理结构

### 1.5.1 逻辑结构

- 集合结构：内部元素同属于一个集合，无其他关系
- 线性结构：内部元素之间是一对一关系
- 树形结构：内部元素之间是一对多关系
- 图形结构：内部元素之间是多对多关系

### 1.5.2 物理结构

- 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
- 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续也可以是不连续的

# 二、算法

## 2.5 算法的特性

算法具有五个基本特性：输入、输出、有穷性、确定性、可行性。

### 2.5.1 输入输出

算法有零个或多个输入，至少有一个或多个输出，输出形式可以是打印输出，也可以是返回一个或多个值。

### 2.5.2 有穷性

指算法在执行有限步骤后，自动结束而不会出现无限循环，且每个步骤在可接受的时间内完成。

### 2.5.3 确定性

算法的每一步骤都具有确定的含义，不会出现二义性。

### 2.5.4 可行性

算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

### 2.6 算法设计的要求

### 2.6.1 正确性

### 2.6.2 可读性

 ### 2.6.3 健壮性

### 2.6.4 时间效率高和存储量低

## 2.9 算法时间复杂度

### 2.9.1 算法时间复杂度定义

语句总的执行次数T(n)是关于问题规模n的函数。算法的时间复杂度，记作T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。

用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。

### 2.9.2 推导大O阶方法

推导大O阶：

1. 用常数1取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 若最高阶项存在且其系数不是1，则去除与这个项相乘的系数

### 2.9.3 常数阶O(1)

分支结构执行次数恒定，不会随着n的变大而发生变化，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度是O(1)。

### 2.9.5 对数阶

```c++
int count = 1;
while(count < n)
{
	count = count * 2;
}
```

有多少个2相乘后会大于n则退出循环，由$2^x=n$得到$x=\log_2n$。故时间复杂度为O($\log n$)。

### 2.9.6 平方阶

```c++
for (int i = 0; i < n; i++)
{
	for (int j = i; j < n; j++)
	{
		// 时间复杂度为O(1)的程序步骤序列
	}
}
```

当$i=0$时，内循环执行$n$次，当$i=1$时，内循环执行$n-1$次，当$i=n-1$时，执行了1次。所以总的执行次数为：
$$
n+(n-1)+(n-2)+\cdots+1=\frac{n(n+1)}{2}=\frac{n^2}{2}+\frac{n}{2}
$$
根据前述推导大O阶方法，时间复杂度为O($n^2$)。

> 常见的时间复杂度所耗时间大小排列：
>
> $O(1)$<$O(\log n)$<$O(n)$<$O(n\log n)$<$O(n^2)$<$O(n^3)$<$O(2^n)$<$O(n!)$<$O(n^n)$

## 2.12 算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，公式为：$S(n)=O(f(n))$，其中n为问题的规模，$f(n)$为语句关于$n$所占存储空间的函数。

